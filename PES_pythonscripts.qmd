---
title: "PES_pythonscripts"
format: html
---

**Script for PES**

```{python}
class calculatePESlevel1A(object): 
    def __init__(self):
        self.label       = "2) Calculate wetland Level 1A PES"
        self.description = "Tool to automate the process of calculating the Level 1A Present Ecological State (PES) " + \
                           "of both depression and non-depression wetlands per the method of Macfarlane, D., Ollis, D., & Kotze, D. (2020)."
        self.category = "9) Present Ecological State (PES)"

        self.canRunInBackground = True 

    def getParameterInfo(self):

        blnInMemory = arcpy.Parameter(
            displayName="Use the 'in_memory' workspace",
            name="inMemory",
            datatype="Boolean",
            parameterType="Required",
            direction="Input")
##        blnInMemory.value = False
        blnInMemory.value = True

        pesReset = arcpy.Parameter(
            displayName="Reset all values of field 'pesDONE' to 0",
            name="splitReset",
            datatype="Boolean",
            parameterType="Required",
            direction="Input")
        pesReset.value = False
        #splitReset.value = True 

        wetlands = arcpy.Parameter(
            displayName="Input: Wetlands feature class",
            name="inputWetlands",
            datatype="DEFeatureClass",
            parameterType="Required",
            direction="Input")
        wetlands.filter.list = ["Polygon"]
##        wetlands.value = r'C:\NWM\wcBerg\wcBerg.gdb\OUTPUT\wcBerg_eAn_nC_PEStest' #$
##        wetlands.value = r'C:\NWM\gpVaal\gpVaal.gdb\OUTPUT\gpVaal_eAn_nC_PEStest'

        wetlandUID = arcpy.Parameter(
            displayName="Field with wetland feature unique identifier",
            name="wetlandUID",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        wetlandUID.value = "featOID"
    
        parameterFolder = arcpy.Parameter(
            displayName="Output location (folder) for parameter text file",
            name="parameterFolder",
            datatype="Folder",
            parameterType="Required",
            direction="Input")
##        parameterFolder.value = r'C:\NWM\wcBerg\pesTest'#$
##        parameterFolder.value = r'C:\NWM\gpVaal\PEStest'

        wetlandSetting = arcpy.Parameter(
            displayName="Input: hydro-geological setting",
            name="wetlandSetting",
            datatype="DEFeatureClass",
            parameterType="Required",
            direction="Input")
        wetlandSetting.filter.list = ["Polygon"]
##        wetlandSetting.value = r'C:\NWM\gpVaal\gpVaal.gdb\Features\Hydroregions'

        settingField = arcpy.Parameter(
            displayName="Field with hydro-geological setting",
            name="settingField",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        settingField.value = "HydroRegions" #$ Reomove after testing
        #targetFCuid.filter.list = ['SHORT', 'LONG']
        settingField.parameterDependencies = [wetlandSetting.name]

##        wetlandSetting = arcpy.Parameter(
##            displayName="Field with wetland landscape setting",
##            name="wetlandSetting",
##            datatype="GPString",
##            parameterType="Required",
##            direction="Input")
##        wetlandSetting.filter.list = ['TEXT']
##        wetlandSetting.parameterDependencies = [wetlands.name]
####        wetlandSetting.value = "Setting"#$

        wetlandType = arcpy.Parameter(
            displayName="Wetland type",
            name="wetlandType",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        wetlandType.value = "Non-depression"
        wetlandType.filter.type = "ValueList"
        wetlandType.filter.list = ["Non-depression", "Depression"]

        field_HGM = arcpy.Parameter(
            displayName="Field with level 4A HGM classification",
            name="fieldHGM",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        field_HGM.value = "HGM_Type"#$

        hgmDefault = arcpy.Parameter(
            displayName="Default HGM",
            name="hgmDefault",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        hgmDefault.value = "None"
        hgmDefault.filter.type = "ValueList"
        hgmDefault.filter.list = ["None", "Floodplain", "Channelled valley-bottom", "Unchannelled valley-bottom", "Seep", "Depression", "Flat"]

        watersheds = arcpy.Parameter(
            displayName="Input: Watershed features",
            name="wetlandWatersheds",
            datatype="DEFeatureClass",
            parameterType="Required",
            direction="Input")
        watersheds.filter.list = ["Polygon"]
##        watersheds.value = r'C:\NWM\wcBerg\wcBerg.gdb\Watersheds\wcBerg_eAn_nC_wshed_PEStest'
##        watersheds.value = r'C:\NWM\gpVaal\gpVaal.gdb\Watersheds\gpVaal_eAn_nC_wshed_PEStest'
##        watersheds.value = r'C:\NWM\gpVaal\gpVaal.gdb\Watersheds\gpVaal_eAn_nC_wshed_PEStest'

        upstreamDistance = arcpy.Parameter(
            displayName="Upstream distance threshold (meters)",
            name="upstrDistance",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")

        field_watersheds = arcpy.Parameter(
            displayName="Watershed field with wetland ID",
            name="fieldWatersheds",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        field_watersheds.value = "featID_org"

        landcover = arcpy.Parameter(
            displayName="Input: Land cover grid",
            name="landcover",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
##        landcover.value = r'C:\NWM\wcBerg\wcBerg_Grids.gdb\SALC2022_extd_totwshed_5km'
##        landcover.value = r'C:\NWM\gpVaal\scratch.gdb\lc2022_PEStest'

        lcField = arcpy.Parameter(
            displayName="Field with broad land cover category ", 
            name="lcField",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        lcField.filter.list = ['SHORT', 'LONG']
        lcField.parameterDependencies = [landcover.name]
        lcField.value = "PES_cat" #$
        
        quatCatchment = arcpy.Parameter(
            displayName="Input: Quaternary catchment feature class",
            name="quatCatchment",
            datatype="DEFeatureClass",
            parameterType="Required",
            direction="Input")
        quatCatchment.filter.list = ["Polygon"]
##        quatCatchment.value = r'C:\NWM\wcBerg\wcBerg.gdb\Features\Quaternary_Catchments'#$
##        quatCatchment.value = r'C:\NWM\gpVaal\gpVaal.gdb\Features\Quaternary_Catchments'

        quatField = arcpy.Parameter( 
            displayName="Field with quaternary catchment name/identifier",
            name="quatField",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
##        quatField.value = "QUATERNARY"#$

        MAPfield = arcpy.Parameter(
            displayName="Quaternary catchment field with the Mean Annual Precipitation (MAP; mm)",
            name="MAP",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
##        MAPfield.value = "MAP"#$

        MAEfield = arcpy.Parameter(
            displayName="Quaternary catchment field with the Mean Annual Evaporation (MAE; mm)",
            name="MAE",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
##        MAEfield.value = "MAE"#$

        errThreshold = arcpy.Parameter(
            displayName="Total land cover area and feature area difference threshold",
            name="errThreshold",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        errThreshold.value = 1
##        errThreshold.value = 5

        #                   0           1       2           3               4               5           6               7           8           9           10              11              12          13          14          15          16        17          18        19
        parameters = [blnInMemory, pesReset, wetlands, wetlandUID, parameterFolder, wetlandSetting, settingField, wetlandType, field_HGM, hgmDefault, watersheds, upstreamDistance, field_watersheds, landcover, lcField, quatCatchment, quatField, MAPfield, MAEfield, errThreshold] 
        return parameters

    def isLicensed(self): #optional
        return True

    def initializeParameters(self):

        return

    def updateParameters(self, parameters): #optional

        #Ensure that the input parameter have a path
        #for i in [2,9,12,14]:
        for i in [13]:
            if parameters[i].altered and not parameters[i].hasBeenValidated:
                if parameters[i].value not in ["", " ", None]:
                    if ":" not in parameters[i].valueAsText:
                        desc = arcpy.Describe(parameters[i].value)
                        path = desc.path
                        parameters[i].value = path + "\\" + parameters[i].valueAsText

            if parameters[2].value not in ["", " ", None]:
                uid = arcpy.Describe(parameters[2].valueAsText).oidFieldName
                fil = []
                fil.append(uid)
                fieldList = arcpy.ListFields(parameters[2].valueAsText)
                for field in fieldList:
                    if field.type == "SmallInteger" or field.type == "Integer":
                        fil.append(field.name)
                
                if len(fil) > 0:
                    fil.sort()
                    if len(fil) == 1:
                        parameters[3].filter.type = "ValueList"
                        parameters[3].filter.list = fil
                        parameters[3].value = fil[0]
                    else:
                        parameters[3].filter.type = "ValueList"
                        parameters[3].filter.list = fil
                

            if parameters[7].value == "Depression":
                parameters[9].value = "None"
                parameters[9].enabled = False
            else:
                parameters[9].enabled = True

            #Populate the wetland ID field
            wetlIDName = ""
##            settingName = ""
            typeName = ""
            idField =[]
            otherFields = []
            if parameters[2].hasBeenValidated == False:
                if parameters[2].value not in ["", " ", None]:
                    wetlandUIDList = arcpy.ListFields(parameters[2].valueAsText)
                    for field in wetlandUIDList:
                        if field.type == "String":
##                            if field.name == "Setting":
##                                settingName = "Setting"
                            if field.name == "HGM_4A":
                                typeName = "HGM_4A"
                            otherFields.append(field.name)

##                        #Populate setting
##                        if len(otherFields) == 1:
##                            parameters[5].filter.type = "ValueList"
##                            parameters[5].filter.list = otherFields
##                            parameters[5].value = otherFields[0]
##                        else:
##                            parameters[5].filter.type = "ValueList"
##                            parameters[5].filter.list = otherFields
##                            if settingName != "":
##                                parameters[5].value = settingName

                        #Populate Level 4A classification
                        if len(otherFields) == 1:
                            parameters[8].filter.type = "ValueList"
                            parameters[8].filter.list = otherFields
                            parameters[8].value = otherFields[0]
                        else:
                            parameters[8].filter.type = "ValueList"
                            parameters[8].filter.list = otherFields
                            if typeName != "":
                                parameters[8].value = typeName

            #Populate the watershed ID field
            parameters[12].value = "featID_org"

            #Populate quarternary atchent parameters
            if parameters[15].value not in [" ", "", None]:
                quatQUAT = ""
                quatMAPfield = ""
                quatMAEfield = ""
                quatField =[]
                typeList = arcpy.ListFields(parameters[15].valueAsText)
                for field in typeList:
                    if field.type == "String":
                        if field.name == "QUATERNARY":
                            quatQUAT = "QUATERNARY"
                        if field.name == "MAP":
                            quatMAPfield = "MAP"
                        if field.name == "MAE":
                            quatMAEfield = "MAE"
                        quatField.append(field.name)

                if len(quatField) > 0:
                    #Populate QUATERNARY field
                    quatField.sort()
                    if len(quatField) == 1:
                        parameters[16].filter.type = "ValueList"
                        parameters[16].filter.list = quatField
                        parameters[16].value = quatField[0]
                    else:
                        parameters[16].filter.type = "ValueList"
                        parameters[16].filter.list = quatField
                        parameters[16].value = quatQUAT

                    if len(quatField) == 1:
                        parameters[17].filter.type = "ValueList"
                        parameters[17].filter.list = quatField
                        parameters[17].value = quatField[0]
                    else:
                        parameters[17].filter.type = "ValueList"
                        parameters[17].filter.list = quatField
                        parameters[17].value = quatMAPfield

                    if len(quatField) == 1:
                        parameters[18].filter.type = "ValueList"
                        parameters[18].filter.list = quatField
                        parameters[18].value = quatField[0]
                    else:
                        parameters[18].filter.type = "ValueList"
                        parameters[18].filter.list = quatField
                        parameters[18].value = quatMAEfield

        if parameters[2].value not in [" ", "", None]:
            if (len(arcpy.ListFields(parameters[2].valueAsText, "pesDONE")) != 0):
                parameters[1].enabled = True
            else:
                parameters[1].value = False
                parameters[1].enabled = False

        parameters[3].enabled = False #the batch tool only accepts the wetland IUD field as unique identifier
        parameters[12].enabled = False #the batch tool only accepts field 'featID_org' as watershed unique identifier
        return

    def updateMessages(self, parameters): #optional

        if parameters[2].value != None:
            if arcpy.Exists(parameters[2].valueAsText):
                type = arcpy.Describe(parameters[2].valueAsText)
                if type.dataType == "ShapeFile":
                    parameters[2].setErrorMessage("Shapefile is not allowed, only geodatabase feature class.")

        if parameters[2].value != None:
            if arcpy.Exists(parameters[2].valueAsText):
                landscapeList = [field.name for field in arcpy.ListFields(parameters[2].valueAsText)]
                if parameters[3].valueAsText not in landscapeList:
                    parameters[3].setErrorMessage("Field '" + str(parameters[3].value) + "' not found in '" + str(parameters[2].value) + "'")

##        if parameters[2].value != None:
##            if arcpy.Exists(parameters[2].valueAsText):
##                landscapeList = [field.name for field in arcpy.ListFields(parameters[2].valueAsText)]
##                if parameters[5].valueAsText not in landscapeList:
##                    parameters[5].setErrorMessage("Field '" + str(parameters[5].value) + "' not found in '" + str(parameters[2].value) + "'")

                wetlandUIDList = arcpy.ListFields(parameters[2].valueAsText)
                for field in wetlandUIDList:
                    if field.type == "String":
                        if field.name == "Setting":
                            if field.length < 15:
                                parameters[5].setErrorMessage("ERROR: Field 'Setting' in '" + os.path.basename(parameters[2].valueAsText) + "' must be at least 15 characters long.")

        if parameters[7].value == "Non-depression":
            if parameters[8].value == None:
                parameters[8].setWarningMessage ("Value is required if 'Wetland type' parameter = 'Non-depression'.")

        # Validate 'wetlandType' and 'field_HGM' parameter      
        if parameters[7].value == "Non-depression" and parameters[8].value == None and parameters[9].value == "None":
            parameters[8].setErrorMessage ("Must be populated if 'Wetland type' = 'Non-depression' AND 'Default HGM' = 'None'.")

        if parameters[2].value != None:
            if parameters[7].value == "Depression":
                fields = [field.name for field in arcpy.ListFields(parameters[2].valueAsText)]
                if "HGM_4C" in fields:
                    if parameters[8].value != "HGM_4C":
                        if "HGM_4A" not in fields:
                            parameters[8].setWarningMessage ("Wetland Feature class includes field 'HGM_4C'. Consider it for this parameter, else field 'HGM_4A' will be created and populated with value 'Depression' for all records.")
                        else:
                            parameters[8].setWarningMessage ("Wetland Feature class includes field 'HGM_4C'. Consider it for this parameter.")
                else:
                    if "HGM_4A" not in fields and parameters[8].value in ["", " ", None]:
                        parameters[8].setWarningMessage ("Field 'HGM_4A' will be created and populated with value 'Depression' for all records.")
                    if "HGM_4A" in fields and parameters[8].value in ["", " ", None]:
                        parameters[8].setErrorMessage ("Wetland Feature class includes field 'HGM_4A'. Consider it or another for this parameter.")
                    
        if parameters[10].value != None:
            if arcpy.Exists(parameters[10].valueAsText):
                type = arcpy.Describe(parameters[10].valueAsText)
                if type.dataType == "ShapeFile":
                    parameters[10].setErrorMessage("Shapefile is not allowed, only geodatabase feature class.")

                if parameters[12].value != None:
                    fields = [field.name for field in arcpy.ListFields(parameters[10].valueAsText)]
                    if parameters[12].valueAsText not in fields:
                        parameters[12].setErrorMessage("Field 'featID_org' not found in watershed Feature class")
                    
        if parameters[15].value != None:
            if arcpy.Exists(parameters[15].valueAsText):
                type = arcpy.Describe(parameters[15].valueAsText)
                if type.dataType == "ShapeFile":
                    parameters[15].setErrorMessage("Shapefile is not allowed, only geodatabase feature class.")                    
        return

    def execute(self, parameters, messages):

        blnInMemory = parameters[0].valueAsText
        pesReset = parameters[1].valueAsText
        wetlands = parameters[2].valueAsText
        wetlandUID = parameters[3].valueAsText
        parameterFolder = parameters[4].valueAsText
        wetlandSetting = parameters[5].valueAsText
        settingField = parameters[6].valueAsText
        wetlandType = parameters[7].valueAsText
        field_HGM = parameters[8].valueAsText
        hgmDefault = parameters[9].valueAsText
        watersheds = parameters[10].valueAsText
        upstreamDistance = parameters[11].valueAsText
        field_watersheds = parameters[12].valueAsText
        landcover = parameters[13].valueAsText
        lcField = parameters[14].valueAsText
        quatCatchment = parameters[15].valueAsText
        quatField = parameters[16].valueAsText
        MAPfield = parameters[17].valueAsText
        MAEfield = parameters[18].valueAsText
        errThreshold = parameters[19].valueAsText 

        BUFF_mag_dic = {} #Create global dictionary
        CATCH_mag_dic = {} #Create global dictionary
        HGM_type = "" #Declare global variable 'HGM_type'

        def clearScratch():   
            try:
                arcpy.Delete_management (scratchWorkspace)
                if scratchWorkspace != "in_memory":
                    if arcpy.Exists (scratchWorkspace):
                        arcpy.AddError ("   - Clearing the scratch workspace '" + scratchWorkspace + "': Failed")
                        arcpy.AddWarning ("    - Error clearing the scratch workspace '" + scratchWorkspace + "'. Possible system lock. Delete manually.\n")
                        exit()
                    else:
                        arcpy.AddMessage ("   - Clearing the scratch workspace '" + scratchWorkspace + "': Succeeded")
            except:
                if scratchWorkspace != "in_memory":
                    arcpy.AddError ("   - Error deleting the scratch workspace '" + scratchWorkspace + "'. Possible system lock. Delete manually.\n")

        def WET_mag (function, zone, multiplier, lc_gridcodes, PES_output, id):
            WET_mag_Total = 0
            if id in zone:
                values = zone[id]
                zone = {}
                for item in values:
                    zone[int(item[0])] = item[1]
                lc_gridcodes = zone.keys()
                for x in lc_gridcodes: #Loop through all the land cover classes (values contained in 'lc_gridcodes')
                    if x in zone: #'lcWetland_area' = dictionary with land cover class and its surface area in the wetland
                        valueArea = float(zone[x]) #Get the percentage area of the clipped landcover class with gridcode x
##                        if id in adjustedNatList:
##                            if x == 1 or x == 3:
##                                valueArea = valueArea * 0.1
                        valueIntensity = float(multiplier[x]) #Get the multiplier

                        # HYDRO_WET, GEO_SEDWET, GEO_STRUCT, VEG_WET
                        BUFF_mag_value = (valueArea * valueIntensity)/100 #Buffer percentage area * multiplier * vulnerability_factor
                        BUFF_mag_dic[x] = BUFF_mag_value #Populate dictionary 'BUFF_mag_' with the WET_mag_ value for that land cover class
                        WET_mag_Total += BUFF_mag_value

                PES_output.append(WET_mag_Total)
            else:
                arcpy.AddWarning ("   - Error for wetland with 'featOID' " + str(id) + ". Suspect inalid wtershed.")

        def BUFF_mag_ (function, zone, multiplier, y, lc_gridcodes, PES_output, vulnerability_factor, watershedInBuffer, id):
            BUFF_mag_Total = 0
            if id in zone:
                values = zone[id]
                zone = {}
                for item in values:
                    zone[int(item[0])] = item[1] #Ryan error
                lc_gridcodes = zone.keys()
                for x in lc_gridcodes: #Loop through all the land cover classes (values contained in 'lc_gridcodes')
                    if x in zone: #'lcWetland_area' = dictionary with land cover class and its surface area in the wetland
                        valueArea = float(zone[x]) #Get the percentage area of the clipped landcover class with gridcode x
##                        if id in adjustedNatList:
##                            if x == 1 or x == 3:
##                                valueArea = valueArea * 0.1
                        valueIntensity = float(multiplier[x]) #Get the multiplier

                        if function == "HYDRO_MAR":
                            if x == 2:
                                if abs((valueArea * y * valueIntensity * vulnerability_factor)/100) < abs(valueIntensity):
                                    BUFF_mag_value = (valueArea * y * valueIntensity * vulnerability_factor)/100
                                else:
                                    BUFF_mag_value = valueIntensity
                            else:
                                BUFF_mag_value = (valueArea * valueIntensity * vulnerability_factor)/100 #Buffer percentage area * multiplier * vulnerability_factor

                        if function == "HYDRO_SEAS" or function == "WQ_EXT" or function == "WQ_WET":
                            if x == 2 or x == 12 or x == 13:
                                if function == "HYDRO_SEAS": # HYDRO_SEAS
                                    if x == 2:
                                        if (valueArea * y * valueIntensity)/100 < valueIntensity:
                                            BUFF_mag_value = (valueArea * y * valueIntensity)/100
                                        else:
                                            BUFF_mag_value = valueIntensity
                                    else:
                                        BUFF_mag_value = (valueArea * valueIntensity)/100
                                        
                                if (function == "WQ_EXT" or function == "WQ_WET") and (x == 12 or x == 13): # WQ_EXT
                                    if (valueArea * y * valueIntensity)/100 < valueIntensity:
                                        BUFF_mag_value = (valueArea * y * valueIntensity)/100
                                    else:
                                        BUFF_mag_value = valueIntensity

                                if (function == "WQ_EXT" or function == "WQ_WET") and (x != 12 and x != 13): # WQ_EXT
                                    BUFF_mag_value = (valueArea * valueIntensity)/100

                            else:
                                BUFF_mag_value = (valueArea * valueIntensity)/100 #Buffer percentage area * multiplier * vulnerability_factor
                                
                        if function == "HYDRO_PEA1" or function == "GEO_SEDEXT":
                            if x == 2:
                                if abs((valueArea * y * valueIntensity )/100) < abs(valueIntensity):
                                    BUFF_mag_value = (valueArea * y * valueIntensity )/100
                                else:
                                    BUFF_mag_value = valueIntensity
                            else:
                                BUFF_mag_value = (valueArea * valueIntensity)/100 #Buffer percentage area * multiplier * vulnerability_factor

                    if watershedInBuffer == 0: #Enter only if the watershed extends beyond the buffer
                        BUFF_mag_dic[x] = BUFF_mag_value #Populate dictionary 'BUFF_mag_' with the BUFF_mag_* value for that land cover class
                        BUFF_mag_Total += BUFF_mag_value
                    else:
                        BUFF_mag_dic[x] = 0 #Assign value 0 if the watershed does not extend beyond the buffer
                        
                if watershedInBuffer == 0: #Enter only if the watershed extends beyond the buffer
                    if function == "HYDRO_MAR" or function == "HYDRO_PEA1" or function == "GEO_SEDEXT":
                        if BUFF_mag_Total < -10:
                            BUFF_mag_Total = -10
                        if BUFF_mag_Total > 10:
                            BUFF_mag_Total = 10
                            
                    if function == "HYDRO_SEAS" or function == "WQ_EXT" or function == "WQ_WET":
                        if BUFF_mag_Total >= 10:
                            BUFF_mag_Total = 10
                else:
                    BUFF_mag_Total = 0 #Assign value 0 if the watershed does not extend beyond the buffer

                if function == "VEG_WET" or function == "WQ_WET":
                    PES_output.append(BUFF_mag_Total)
            else:
                pass
                
        def CATCH_mag_ (function, zone, multiplier, vulnerability_factor, y, lc_gridcodes, id):
            CATCH_mag_Total = 0
            if id in zone:
                values = zone[id]
                zone = {}
                for item in values:
                    zone[int(item[0])] = item[1]
                lc_gridcodes = zone.keys()
                for x in lc_gridcodes: #Loop through all the land cover classes (values contained in 'lc_gridcodes)
                    if x in zone: #'lcWetland_area' = dictionary with land cover class and its surface area in the wetland
                        valueArea = float(zone[x]) #Get the percentage area of the clipped landcover class with gridcode x
##                        if id in adjustedNatList:
##                            if x == 1 or x == 3:
##                                valueArea = valueArea * 0.1
                        valueIntensity = float(multiplier[x]) #Get the multiplier

                        if function == "HYDRO_MAR":
                            if x == 2:
                                if abs((valueArea * y * valueIntensity * vulnerability_factor)/100) < abs(valueIntensity):
                                    CATCH_mag_value = (valueArea * y * valueIntensity * vulnerability_factor)/100
                                else:
                                    CATCH_mag_value = valueIntensity
                            else:
                                CATCH_mag_value = (valueArea * valueIntensity * vulnerability_factor)/100 #Buffer percentage area * multiplier * vulnerability_factor

                        if function == "HYDRO_SEAS" or function == "WQ_EXT":
                            if x == 2 or x == 12 or x == 13:
                                if function == "HYDRO_SEAS": # HYDRO_SEAS
                                    if x == 2:
                                        if (valueArea * y * valueIntensity)/100 < valueIntensity:
                                            CATCH_mag_value = (valueArea * y * valueIntensity)/100
                                        else:
                                            CATCH_mag_value = valueIntensity
                                    else:
                                        CATCH_mag_value = (valueArea * valueIntensity)/100
                                        
                                if function == "WQ_EXT" and (x == 12 or x == 13): # WQ_EXT
                                    if (valueArea * y * valueIntensity)/100 < valueIntensity:
                                        CATCH_mag_value = (valueArea * y * valueIntensity)/100
                                    else:
                                        CATCH_mag_value = valueIntensity
                                        
                                if function == "WQ_EXT" and (x != 12 and x != 13): # WQ_EXT
                                    CATCH_mag_value = (valueArea * valueIntensity)/100
                                    
                            else:
                                CATCH_mag_value = (valueArea * valueIntensity)/100 #Buffer percentage area * multiplier * vulnerability_factor

                        if function == "HYDRO_PEA1" or function == "GEO_SEDEXT":
                            if x == 2:
                                if abs((valueArea * y * valueIntensity )/100) < abs(valueIntensity):
                                    CATCH_mag_value = (valueArea * y * valueIntensity )/100
                                else:
                                    CATCH_mag_value = valueIntensity
                            else:
                                CATCH_mag_value = (valueArea * valueIntensity)/100 #Buffer percentage area * multiplier * vulnerability_factor

                    CATCH_mag_dic[x] = CATCH_mag_value #Populate dictionary 'CATCH_mag_' with the CATCH_mag_* value for that land cover class
                    CATCH_mag_Total += CATCH_mag_value #&Remove after testing - does not seem to contribute towards PES result
                        
                if function == "HYDRO_MAR" or function == "HYDRO_PEA1" or function == "GEO_SEDEXT":
                    if CATCH_mag_Total < -10:
                        CATCH_mag_Total = -10
                    if CATCH_mag_Total > 10:
                        CATCH_mag_Total = 10

                if function == "HYDRO_SEAS" or function == "WQ_EXT":
                    if CATCH_mag_Total >= 10:
                        CATCH_mag_Total = 10
            else:
                pass
            
        def EXT_MAR (zone, lc_gridcodes, HGM_type, HGMdic, PES_output, id):
            EXT_MAR_Total = 0
            if id in zone:
                values = zone[id]
                zone = {}
                for item in values:
                    zone[int(item[0])] = item[1]
                lc_gridcodes = zone.keys()
                for x in lc_gridcodes: #Loop through all the land cover classes (values contained in 'lc_gridcodes)
                    if x in zone: #'lcWetland_area' = dictionary with land cover class and its surface area in the wetland
                        try:
                            BUFF_mag_Lookup = BUFF_mag_dic[x] #Get the 'BUFF_mag_' value for the different land cover classes
                        except:
                            BUFF_mag_Lookup = 0.0
                        try:
                            CATCH_mag_Lookup = CATCH_mag_dic[x] #Get the 'CATCH_mag_' value for the different land cover classes
                        except:
                            CATCH_mag_Lookup = 0.0

                        HGMvalues = HGMdic.get(HGM_type)
                        HGM_Lookup_CATCH = HGMvalues[0] #Get the HGM type watershed relative weighting
                        HGM_Lookup_BUFF = HGMvalues[1] #Get the HGM type buffer relative weighting
                        
                        EXT_MAR = (BUFF_mag_Lookup * HGM_Lookup_BUFF) + (CATCH_mag_Lookup * HGM_Lookup_CATCH)
                        EXT_MAR_Total += EXT_MAR

                PES_output.append(EXT_MAR_Total)
            else:
                pass
# try
        #def calculatePES (parameterCounter, featureCounter, nFeatures):
        def calculatePES (upstreamDistance,wetlands,lcField,wetlands_org):
            lcList = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]

##            arcpy.AddMessage ("\nlcField: " + str(lcField))#$
##            exit()#$

            wetlands_tmp = scratchWorkspace + "\\wetlands_tmp"
            arcpy.CopyFeatures_management(wetlands,wetlands_tmp)
##            arcpy.AddField_management (wetlands_tmp, "PESselect", "SHORT")
##            arcpy.CopyFeatures_management(wetlands_tmp,r'C:\NWM\scratch.gdb\wetlands_tmp_x')#$
            arcpy.MakeFeatureLayer_management(wetlands_tmp,"wetlands_tmp")
#qqq
            fcCount = 0
            failList = []
            failListCheck = []
##            countPES = 1
##            onlyNull = 0
            featureCount = 0
##            while onlyNull == 0:
##            Selection_Count = int(arcpy.GetCount_management("wetlands_tmp").getOutput(0))
##            arcpy.AddMessage("       - Loop " + str(countPES) + "; Calculating PES for " + str(Selection_Count) + " features ...")
##            featureCount = Selection_Count
##                countPES += 1
##            arcpy.CopyFeatures_management("wetlands_tmp",r'C:\NWM\scratch.gdb\wetlands_tmp_loop')#$

            lcWetlandList = []
            lcBufferList = []
            lcWatershedList = []
            PES_summary = []
            PES_summary_dic = {}            

##            if fcCount == Selection_Count: #i.e. only records with value '<NULL>' in field 'EC_ALL' remain
##                onlyNull = 1

            wshedComplWithinVar = 0 #Variable to keep track whether the watershed is completely contained within the 200 meter buffer; = 0 if false, = 1 if true
            lcWetlandVar = 0 #Variable to keep track whether the Total wetland land cover area differs from wetland area; = 0 if false, = 1 if true
            lcBufferVar = 0 #Variable to keep track whether the Total buffer land cover area differs from buffer area; = 0 if false, = 1 if true
            lcWatershedVar = 0 #Variable to keep track whether the Total watershed land cover area differs from watershed area; = 0 if false, = 1 if true
            lcBufferWatershedVar = 0 #Variable to keep track whether the Watershed does not extend beyond the wetland; = 0 if false, = 1 if true

            #Create list with all wetlands unique identifier values
            allWetlList = []
            with arcpy.da.SearchCursor ("wetlands_tmp", [wetlandUID,]) as cursor:
                for row in cursor:
                    allWetlList.append(row[0])
##            arcpy.AddMessage ("allWetlList_n: " + str(len(allWetlList)))#$
##            arcpy.AddMessage ("allWetlList: " + str(allWetlList))#$


## SETTING START
            #Determine in which quaternary catchment the wetland is located
            arcpy.AddMessage ("     - Determining hydro-geological setting...")
            fields = [field.name for field in arcpy.ListFields(wetlandSetting)]
            settingJoin = scratchWorkspace + "\\settingJoin"
##            arcpy.CopyFeatures_management("wetlands_tmp",r'C:\NWM\lpOliphants\scratch.gdb\wetlands_tmp')#$
##            arcpy.CopyFeatures_management(wetlandSetting,r'C:\NWM\lpOliphants\scratch.gdb\wetlandSetting')#$
            arcpy.SpatialJoin_analysis ("wetlands_tmp", wetlandSetting, settingJoin, "JOIN_ONE_TO_ONE", "KEEP_ALL", "", "INTERSECT", "", "")
##            arcpy.CopyFeatures_management(settingJoin,r'C:\NWM\scratch.gdb\settingJoin')#$

##            if (len(arcpy.ListFields("Setting", "altExp_" + catText)) == 0):
##                arcpy.AddField_management("fc", "altExp_" + catText, "SHORT")

            systemFields = ["OID", "OBJECTID", "SHAPE", "Shape", "shape", "SHAPE_Length", "SHAPE_Area", "Shape_Length", "Shape_Area"]
            settingFields = [wetlandUID,settingField]
            for field in fields:
                if field not in systemFields and field not in settingFields:
                    try:
                        arcpy.DeleteField_management(settingJoin, [field])
                    except:
                        pass

            #Select the wetlands that intersect quaternary boundaries, these are the ones for which the largest proprtion wetland in catchment needs to be determined to assign it the most 'appropriate' MAE, MAR and MAP values
##            wetlandsUID = arcpy.Describe(wetlands).oidFieldName
            wetlandSettingLine = scratchWorkspace + "\\wetlandSettingLine"
##            settingField = "Setting"
            arcpy.PolygonToLine_management (wetlandSetting, wetlandSettingLine)
            arcpy.SelectLayerByLocation_management("wetlands_tmp", "INTERSECT", wetlandSettingLine, "", "NEW_SELECTION")
            settingIDlist = []
            #with arcpy.da.SearchCursor ("wetlands_tmp", [wetlands_tmpUID, ]) as cursor:
            with arcpy.da.SearchCursor ("wetlands_tmp", [wetlandUID, ]) as cursor:
                for row in cursor:
                    settingIDlist.append(row[0])

            #Determine the setting region that has the largest propoerion of the intersecting wetland
##            arcpy.CopyFeatures_management(settingJoin,r'C:\NWM\lpOliphants\scratch.gdb\settingJoin2')#$
            wetSetDic = {}
##            arcpy.AddMessage ("wetlandUID: " + str(wetlandUID))#$
##            arcpy.AddMessage ("settingField: " + str(settingField))#$
            settingUID = arcpy.Describe(wetlandSetting).oidFieldName
            with arcpy.da.SearchCursor(settingJoin, [wetlandUID,settingField]) as cursor: 
                for row in cursor:
                    i = row[0]
##                    arcpy.AddMessage ("i: " + str(i))#$
                    #arcpy.AddMessage ("      - Calculating MAP and MAE values for wetland '" + str(i) + "' ...")
                    if row[0] not in settingIDlist: #i.e. the wetland does not intersect >1 setting region
                        settingValidate = str(row[1])
##                        MAEfieldValidate = str(row[2])
##                        arcpy.AddMessage ("settingValidate: " + str(row[1]))#$
##                        arcpy.AddMessage ("MAEfieldValidate: " + str(row[1]))#$

                        if settingValidate in ["", " ", "None", None]:
                            arcpy.AddWarning ("       - WARNING: Invalid hydro-geological type value.")
                            raise TypeError("Values in the hydro-geological type field are not allowed to be empty. Suspect that wetlands extend beyond the hydro-geological type extent.")

##                        arcpy.AddMessage ("settingValue: " + str(row[1]))#$
##                        arcpy.AddMessage ("MAEvalue: " + str(row[2]))#$
##                        settingValue = float(row[1].replace(',', '.')) #Create a variable to hold the MAP value
##                        MAEvalue = float(row[2].replace(',', '.')) #Create a variable to hold the MAE value
##                        try:
##                            settingValue = float(row[1].replace(',', '.')) #Create a variable to hold the MAP value
##                        except:
##                            settingValue = float(row[1])
                        settingValue = str(row[1])
##                        try:
##                            MAEvalue = float(row[2].replace(',', '.')) #Create a variable to hold the MAE value
##                        except:
##                            MAEvalue = float(row[2])
                    else: #i.e. the wetland does intersect >1 setting region
                        try:
                            #sql = wetlands_tmpUID + " = '" + str(i) + "'"
                            sql = wetlandUID + " = '" + str(i) + "'"
                            arcpy.SelectLayerByAttribute_management("wetlands_tmp", "NEW_SELECTION", sql)# Select the wetland
                        except:
                            #sql = wetlands_tmpUID + " = " + str(i)
                            sql = wetlandUID + " = " + str(i)
                            arcpy.SelectLayerByAttribute_management("wetlands_tmp", "NEW_SELECTION", sql)# Select the wetland

                        arcpy.MakeFeatureLayer_management(wetlandSetting, "wetlandSetting")
                        arcpy.SelectLayerByLocation_management ("wetlandSetting", "INTERSECT", "wetlands_tmp", "", "NEW_SELECTION")#Select the setting regions in whcih the wetland is located
                        quatCounter = int(arcpy.GetCount_management("wetlandSetting").getOutput(0)) #Determine if >1 setting region is selected

                        arcpy.AddWarning("       - WARNING: Wetland with '" + wetlandUID + "' " + str(i) + " extends over " + str(quatCounter) + " hydro-geological regions. Determining region with largest portion of wetland.")
                        settingClip = scratchWorkspace + "\\settingClip"
                        arcpy.Clip_analysis ("wetlandSetting", "wetlands_tmp", settingClip)

                        area_var = 0
                        settingID = ""
                        with arcpy.da.SearchCursor(settingClip, [settingUID, "SHAPE@AREA"]) as cursor:
                            for row in cursor:
                                if row[1] > area_var:
                                    area_var = row[1]
                                    settingID = row[0]

                        sql = str(settingUID) + " = " + str(settingID)
                        arcpy.SelectLayerByAttribute_management ("wetlandSetting", "NEW_SELECTION", sql)

                        with arcpy.da.SearchCursor ("wetlandSetting", [settingField,]) as cursor: 
                            for row in cursor:

                                settingValidate = str(row[0])
##                                MAEfieldValidate = str(row[1])

                                if settingValidate in ["", " ", "None", None] :
                                    arcpy.AddWarning ("       - WARNING: Invalid hydro-geological value. Continuing to the next feature.")
                                    raise TypeError("Values in the hydro-geological regions are not allowed to be empty.")

##                                settingValue = float(row[0].replace(',', '.')) #Create a variable to hold the Setting value
                                settingValue = str(row[0])
##                                MAEvalue = float(row[1].replace(',', '.')) #Create a variable to hold the MAE value

##                        if MAEvalue == 0:
##                            arcpy.AddWarning ("       - WARNING: An unexpected error occurred. Continuing to the next feature.")
##                            raise

                    #Populate the parameters
##                    xlist = ["Other","Karst landscape","Coastal plain"]#$
##                    if settingValue not in xlist:#$
##                        arcpy.AddMessage ("ERROR: " + str(i))#$
                    wetSetDic[i] = str(settingValue) #To get the MAPfield, MAEfield, MARfield values of each wetland to write to parameter text file

##            arcpy.AddMessage ("\n wetSetDic: " + str(wetSetDic))#$

            if (len(arcpy.ListFields(wetlands_org, "Setting")) != 0): 
                arcpy.DeleteField_management(wetlands_org, ["Setting",])
            arcpy.AddField_management (wetlands_org, "Setting", "TEXT", "", "", 50)

##            arcpy.AddMessage ("wetSetDic: " + str(wetSetDic))#$
##            arcpy.CopyFeatures_management(wetlands_org,r'C:\NWM\scratch.gdb\wetlands_org')#$
            with arcpy.da.UpdateCursor (wetlands_org, [wetlandUID, "Setting"]) as cursor:
                for row in cursor:
                    if row[0] in wetSetDic:
##                        arcpy.AddMessage ("\n row[0]: " + str(row[0]))#$
##                        arcpy.AddMessage ("value: " + str(wetSetDic[row[0]]))#$
                        row[1] = str(wetSetDic[row[0]])
                        cursor.updateRow(row)
##            arcpy.CopyFeatures_management(wetlands,r'C:\NWM\scratch.gdb\wetlands1')#$
            
## SETTING END Setting

            arcpy.SelectLayerByAttribute_management("wetlands_tmp", "CLEAR_SELECTION")

            MAPvalue = 0 #Create a variable to hold the MAP value
            MAEvalue = 0 #Create a variable to hold the MAE value

            #Create list with all wetlands unique identifier values
            if (len(arcpy.ListFields("wetlands_tmp", MAPfield)) != 0):
                arcpy.DeleteField_management("wetlands_tmp", [MAPfield,])
                
            if (len(arcpy.ListFields("wetlands_tmp", MAEfield)) != 0): 
                arcpy.DeleteField_management("wetlands_tmp", [MAEfield,])
                
            #Determine in which quaternary catchment the wetland is located
            arcpy.AddMessage ("     - Calculating MAP and MAE values ...")
            fields = [field.name for field in arcpy.ListFields(quatCatchment)]
            quatJoin = scratchWorkspace + "\\quatJoin"
##            arcpy.CopyFeatures_management("wetlands_tmp",r'C:\NWM\lpOliphants\scratch.gdb\wetlands_tmp')#$
##            arcpy.CopyFeatures_management(quatCatchment,r'C:\NWM\lpOliphants\scratch.gdb\quatCatchment')#$
            arcpy.SpatialJoin_analysis ("wetlands_tmp", quatCatchment, quatJoin, "JOIN_ONE_TO_ONE", "KEEP_ALL", "", "INTERSECT", "", "")
##            arcpy.CopyFeatures_management(quatJoin,r'C:\NWM\lpOliphants\scratch.gdb\quatJoin1')#$

            systemFields = ["OID", "OBJECTID", "SHAPE", "Shape", "shape", "SHAPE_Length", "SHAPE_Area", "Shape_Length", "Shape_Area"]
            quatFields = [quatField,MAPfield,MAEfield]
            for field in fields:
                if field not in systemFields and field not in quatFields:
                    try:
                        arcpy.DeleteField_management(quatJoin, [field])
                    except:
                        pass

            #Select the wetlands that intersect quaternary boundaries, these are the ones for which the largest proprtion wetland in catchment needs to be determined to assign it the most 'appropriate' MAE, MAR and MAP values
##            wetlandsUID = arcpy.Describe(wetlands).oidFieldName
            quatCatchmentLine = scratchWorkspace + "\\quatCatchmentLine"
            arcpy.PolygonToLine_management (quatCatchment, quatCatchmentLine)
            arcpy.SelectLayerByLocation_management("wetlands_tmp", "INTERSECT", quatCatchmentLine, "", "NEW_SELECTION")
            quatIDlist = []
            #with arcpy.da.SearchCursor ("wetlands_tmp", [wetlands_tmpUID, ]) as cursor:
            with arcpy.da.SearchCursor ("wetlands_tmp", [wetlandUID, ]) as cursor:
                for row in cursor:
                    quatIDlist.append(row[0])

            #Determine the quaternary catchment that has the largest propoerion of the intersecting wetland
##            arcpy.CopyFeatures_management(quatJoin,r'C:\NWM\lpOliphants\scratch.gdb\quatJoin2')#$
            with arcpy.da.SearchCursor(quatJoin, [wetlandUID,MAPfield,MAEfield]) as cursor: 
                for row in cursor:
                    i = row[0]
##                    arcpy.AddMessage ("i: " + str(i))#$
                    #arcpy.AddMessage ("      - Calculating MAP and MAE values for wetland '" + str(i) + "' ...")
                    if row[0] not in quatIDlist: #i.e. the wetland does not intersect >1 quaternary catchment
                        MAPfieldValidate = str(row[1])
                        MAEfieldValidate = str(row[2])
##                        arcpy.AddMessage ("MAPfieldValidate: " + str(row[1]))#$
##                        arcpy.AddMessage ("MAEfieldValidate: " + str(row[1]))#$

                        if MAPfieldValidate in ["", " ", "None", None] or MAEfieldValidate in ["", " ", "None", None]:
                            arcpy.AddWarning ("       - WARNING: Invalid MAP and/or MAE value. Continuing to the next feature.")
                            raise TypeError("Values in the MAP and/or MAE are not allowed to be empty. Suspect that wetlands extend beyond the quaternary catchment extent.")

##                        arcpy.AddMessage ("MAPvalue: " + str(row[1]))#$
##                        arcpy.AddMessage ("MAEvalue: " + str(row[2]))#$
##                        MAPvalue = float(row[1].replace(',', '.')) #Create a variable to hold the MAP value
##                        MAEvalue = float(row[2].replace(',', '.')) #Create a variable to hold the MAE value
                        try:
                            MAPvalue = float(row[1].replace(',', '.')) #Create a variable to hold the MAP value
                        except:
                            MAPvalue = float(row[1])
                        try:
                            MAEvalue = float(row[2].replace(',', '.')) #Create a variable to hold the MAE value
                        except:
                            MAEvalue = float(row[2])
                    else: #i.e. the wetland does intersect >1 quaternary catchment
                        try:
                            #sql = wetlands_tmpUID + " = '" + str(i) + "'"
                            sql = wetlandUID + " = '" + str(i) + "'"
                            arcpy.SelectLayerByAttribute_management("wetlands_tmp", "NEW_SELECTION", sql)# Select the wetland
                        except:
                            #sql = wetlands_tmpUID + " = " + str(i)
                            sql = wetlandUID + " = " + str(i)
                            arcpy.SelectLayerByAttribute_management("wetlands_tmp", "NEW_SELECTION", sql)# Select the wetland

                        arcpy.MakeFeatureLayer_management(quatCatchment, "quatCatchment")
                        arcpy.SelectLayerByLocation_management ("quatCatchment", "INTERSECT", "wetlands_tmp", "", "NEW_SELECTION")#Select the quaternary catchment in whcih the wetland is located
                        quatCounter = int(arcpy.GetCount_management("quatCatchment").getOutput(0)) #Determine if >1 quaternary catchment is selected

                        arcpy.AddWarning("       - WARNING: Wetland with '" + wetlandUID + "' " + str(i) + " extends over " + str(quatCounter) + " quaternary catchments. Determining quaternary with largest portion of wetland.")
                        quatClip = scratchWorkspace + "\\quatClip"
                        arcpy.Clip_analysis ("quatCatchment", "wetlands_tmp", quatClip)

                        area_var = 0
                        quatID = ""
                        with arcpy.da.SearchCursor(quatClip, [quatField, "SHAPE@AREA"]) as cursor:
                            for row in cursor:
                                if row[1] > area_var:
                                    area_var = row[1]
                                    quatID = row[0]

                        sql = str(quatField) + " = '" + str(quatID) + "'"
                        arcpy.SelectLayerByAttribute_management ("quatCatchment", "NEW_SELECTION", sql)

                        with arcpy.da.SearchCursor ("quatCatchment", [MAPfield, MAEfield]) as cursor: #Remove 'quatCatchmentID' from list after testing
                            for row in cursor:

                                MAPfieldValidate = str(row[0])
                                MAEfieldValidate = str(row[1])

                                if MAPfieldValidate in ["", " ", "None", None] or MAEfieldValidate in ["", " ", "None", None]:
                                    arcpy.AddWarning ("       - WARNING: Invalid MAP and/or MAE value. Continuing to the next feature.")
                                    raise TypeError("Values in the MAP and/or MAE are not allowed to be empty")

                                MAPvalue = float(row[0].replace(',', '.')) #Create a variable to hold the MAP value
                                MAEvalue = float(row[1].replace(',', '.')) #Create a variable to hold the MAE value

                        if MAEvalue == 0:
                            arcpy.AddWarning ("       - WARNING: An unexpected error occurred. Continuing to the next feature.")
                            raise

                    #Populate the parameters
                    quatDic[i] = [MAPvalue, MAEvalue] #To get the MAPfield, MAEfield, MARfield values of each wetland to write to parameter text file

                    #Calculate the vulnerability factor
                    MAP_PET = float(MAPvalue) / float(MAEvalue)

                    if MAP_PET <= 0.2:
                        vulnerability_factor = 1
                    if MAP_PET > 0.2 and MAP_PET <= 0.36:
                        vulnerability_factor = 0.95
                    if MAP_PET > 0.36 and MAP_PET <= 0.5:
                        vulnerability_factor = 0.9
                    if MAP_PET > 0.5 and MAP_PET <= 0.65:
                        vulnerability_factor = 0.85
                    if MAP_PET > 0.65:
                        vulnerability_factor = 0.8
                    vulnFactDic[i] = vulnerability_factor #To hold the wetland vulnerability factor

##                #Remove all field with 'ORIG_FID' from all feature classes
##                arcpy.AddMessage ("     - Deleting superfluous fields from feature classes ...")
##                delFieldsList = ["wshedQual","ORIG_FID","Join_Count","TARGET_FID","BUFF_DIST","gridcode","wetlID"]
##                fcList = [wetlands_tmp,watersheds]
##                delList = []
##                for fc in fcList:
##                    arcpy.AddMessage ("      - For feature class '" +  os.path.basename(fc) + "' ...")
##                    fields = [field.name for field in arcpy.ListFields(fc)]
##                    for field in fields:
##                        if field in delFieldsList:
##                            delList.append(field)
##                    if len(delList) > 0:
##                        delTxt =  ", ".join(str(x) for x in delList)
##                        arcpy.AddMessage ("       - Deleting fields: " + delTxt + " ...")
##                        arcpy.DeleteField_management (fc, delList)#
##                    else:
##                        arcpy.AddMessage ("       - No superfluous fields found.")

            #Select the watersheds that have wetlands
            arcpy.SelectLayerByAttribute_management ("wetlands_tmp", "CLEAR_SELECTION")
            wshedIDlist = []
            with arcpy.da.SearchCursor ("wetlands_tmp", [wetlandUID,]) as cursor: 
                for row in cursor:
                    wshedIDlist.append(row[0])
                    
            if (len(arcpy.ListFields(watersheds, "valWshed")) == 0):
                arcpy.AddField_management(watersheds, "valWshed", "SHORT")
            with arcpy.da.UpdateCursor(watersheds, [field_watersheds,"valWshed"]) as cursor:
                for row in cursor:
                    if row[0] in wshedIDlist:
                        row[1] = 1
                    else:
                        row[1] = 0
                    cursor.updateRow(row)
                    
            arcpy.MakeFeatureLayer_management(watersheds,"watersheds")
            sql = "valWshed = 1"
            arcpy.SelectLayerByAttribute_management ("watersheds", "NEW_SELECTION", sql)
            
            #Create the 200m buffer around the wetland
            featIDdic = {}
            with arcpy.da.SearchCursor ("wetlands_tmp", ["OID@","featOID"]) as cursor:
                for row in cursor:
                    featIDdic[row[0]] = row[1]  

            #Add and populate field 'featID_buff'
            arcpy.AddMessage ("     - Creating the 200 m wetland buffers ...")
            arcpy.Buffer_analysis ("wetlands_tmp", wetlandBuffer, "200 Meters", "OUTSIDE_ONLY") #field 'ORIG_FID' has the origanl wetland buffer id
            #Create and update field 'featID_buff' with the unique identifier from 'featOID'
            arcpy.AddField_management(wetlandBuffer, "featID_buff", "LONG")   
            with arcpy.da.UpdateCursor (wetlandBuffer, ["ORIG_FID","featID_buff"]) as cursor:
                for row in cursor:
                    row[1] = featIDdic[row[0]]
                    cursor.updateRow(row)
            
            #Delete the superfluous fields
            fields = [field.name for field in arcpy.ListFields(wetlandBuffer)]
            for field in fields:
                if field not in ["WetlID","ORIG_FID","featID_buff"]:
                    try:
                        arcpy.DeleteField_management (wetlandBuffer, [field,])
                    except:
                        pass
            arcpy.AddField_management(wetlandBuffer, "bufferID", "SHORT")
            arcpy.CalculateField_management (wetlandBuffer, "bufferID", '{}'.format(1), "PYTHON")
##            arcpy.CopyFeatures_management(wetlandBuffer,r'C:\NWM\scratch.gdb\aa_wetlandBuffer_a')#$

            #Create the upstream distance buffer
            if upstreamDistance not in ["", " ", None]:
                upstreamDistance = upstreamDistance + " Meters"
                arcpy.Buffer_analysis ("wetlands_tmp", wetlandUpstreamBuffer, upstreamDistance, "OUTSIDE_ONLY") #field 'ORIG_FID' has the origanl wetland buffer id
                
                #Delete the superfluous fields
                fields = [field.name for field in arcpy.ListFields(wetlandUpstreamBuffer)]
                for field in fields:
                    if field not in ["WetlID","ORIG_FID","featID_buff"]:
                        try:
                            arcpy.DeleteField_management (wetlandUpstreamBuffer, [field,])
                        except:
                            pass
                #arcpy.AlterField_management (wetlandUpstreamBuffer, "ORIG_FID", "featID_buff", "featID_buff")
                arcpy.AlterField_management (wetlandUpstreamBuffer, "ORIG_FID", "featID_buff_upstr", "featID_buff_upstr")
                arcpy.AddField_management(wetlandUpstreamBuffer, "upstreamID", "SHORT")
                arcpy.CalculateField_management (wetlandUpstreamBuffer, "upstreamID", '{}'.format(1), "PYTHON")
##                arcpy.CopyFeatures_management(wetlandUpstreamBuffer,r'C:\NWM\scratch.gdb\aa_wetlandUpstreamBuffer_a')#$

            wetlDiss = scratchWorkspace + "\\wetlDiss"
            tempFC = scratchWorkspace + "\\tempFC"
            bufferDiss = scratchWorkspace + "\\bufferDiss"
            wshedDiss = scratchWorkspace + "\\wshedDiss"
            wshedDissInside = scratchWorkspace + "\\wshedDissInside"
            wshedDissInsideWetl = scratchWorkspace + "\\wshedDissInsideWetl"

            ##ID FIELDS FOR FEATURE CLASSES
            #Wetlands: featOID
            #Buffer: featID_buff
            #Watershed: featID_org

##                arcpy.AddMessage ("\n>>> Creating union of wetlands, buffers and watersheds ...")
            arcpy.AddMessage ("     - Creating union of wetlands, buffers and watersheds ...")
            if upstreamDistance not in ["", " ", None]:
                arcpy.Union_analysis (["wetlands_tmp",wetlandBuffer,"watersheds",wetlandUpstreamBuffer], fcUnion)
            else:
                arcpy.Union_analysis (["wetlands_tmp",wetlandBuffer,"watersheds"], fcUnion)
##            arcpy.CopyFeatures_management(fcUnion,r'C:\NWM\scratch.gdb\aa_fcUnion_tmp_a')#$

##                #Clip land cover to union extent
##                arcpy.AddMessage ("     - Clipping union to features extent ...")
##                arcpy.Clip_analysis (lcPolygon, fcUnion_tmp, lcPolygonClip)
##                arcpy.AddMessage ("     - Creating union of land cover with features ...")
##                arcpy.Union_analysis ([fcUnion_tmp,lcPolygonClip], fcUnion)
##                arcpy.CopyFeatures_management(fcUnion,r'C:\NWM\scratch.gdb\fcUnion')#$

            arcpy.MakeFeatureLayer_management(fcUnion,"fcUnion")

            ##Select the wetland
            #Select polygons of the same wetland on account of field 'WetlID', e.g. WetlID ='{F86713AB-7FD3-4AEC-B5D1-47366598CA19}' 
            arcpy.AddMessage ("     - Selecting wetlands ...")
            sql = "featOID <> 0"
            arcpy.SelectLayerByAttribute_management ("fcUnion", "NEW_SELECTION", sql)
            arcpy.Dissolve_management ("fcUnion", wetlDiss, ["featOID",], "", "MULTI_PART", "")

            ##Select the watersheds (including wetland and buffer)
            #Select polygons of the same watershed on account of field 'fietdID', e.g. featID ='{F86713AB-7FD3-4AEC-B5D1-47366598CA19}' 
            arcpy.AddMessage ("     - Selecting watersheds (including wetland and buffer) ...")
            if upstreamDistance not in ["", " ", None]:
                #sql = "featID_org <> 0 and upstreamID = 1"
                sql = "(" + field_watersheds + " <> 0 and upstreamID = 1) OR (" + field_watersheds + " <> 0 and " + wetlandUID + " <> 0)"
            else:
                #sql = "featID_org <> 0"
                sql = field_watersheds + " <> 0"
            arcpy.SelectLayerByAttribute_management ("fcUnion", "NEW_SELECTION", sql)
            arcpy.Dissolve_management ("fcUnion", wshedDiss, ["featID_org",], "", "MULTI_PART", "")
##            arcpy.CopyFeatures_management(wshedDiss,r'C:\NWM\scratch.gdb\aa_wshedDiss_a')#$

            arcpy.AddMessage ("     - Selecting buffers ...")
            trueBuffer = scratchWorkspace + "\\trueBuffer"
            extractedBuffers = scratchWorkspace + "\\extractedBuffers"
            unionBufWshed = scratchWorkspace + "\\unionBufWshed"
            
            arcpy.AddMessage ("      - Extracting the buffers ...")
##            if wetlandType == "Depression":
            sql = "featID_buff <> 0"
            arcpy.SelectLayerByAttribute_management ("fcUnion", "NEW_SELECTION", sql)
##            arcpy.CopyFeatures_management("fcUnion",r'C:\NWM\scratch.gdb\aa_buff_aa')#$
            arcpy.CopyFeatures_management("fcUnion",extractedBuffers)
            arcpy.AddField_management(extractedBuffers, "extrBuffer", "SHORT")
##            arcpy.CopyFeatures_management(extractedBuffers,r'C:\NWM\scratch.gdb\aa_buff_ab')#$
            arcpy.MakeFeatureLayer_management(extractedBuffers,"extractedBuffers")

            #Delete buffers that intersect thw watersheds of other wetlands
            arcpy.AddMessage ("      - Removing portions that intersect neighbouring watersheds ...")
            #sql = wshed_FID + " <> " + origFID
            sql = "featID_org <> featID_buff"
            arcpy.SelectLayerByAttribute_management ("extractedBuffers", "NEW_SELECTION", sql)
##            arcpy.CopyFeatures_management("extractedBuffers",r'C:\NWM\scratch.gdb\aa_buff_b')#$
            arcpy.DeleteFeatures_management ("extractedBuffers")
##            arcpy.CopyFeatures_management("extractedBuffers",r'C:\NWM\scratch.gdb\aa_buff_c')#$

            arcpy.AddMessage ("      - Dissolving ...")
            arcpy.Dissolve_management ("extractedBuffers", bufferDiss,["featID_buff",], "", "MULTI_PART", "")
##            arcpy.CopyFeatures_management(bufferDiss,r'C:\NWM\scratch.gdb\aa_bufferDiss_a')#$
##            else:
##                sql = "featID_buff <> 0"
##                arcpy.SelectLayerByAttribute_management ("fcUnion", "NEW_SELECTION", sql)
##                arcpy.CopyFeatures_management("fcUnion",r'C:\NWM\scratch.gdb\aa_buff_aa')#$
##                arcpy.CopyFeatures_management("fcUnion",extractedBuffers)
##                arcpy.AddField_management(extractedBuffers, "extrBuffer", "SHORT")
##                arcpy.CopyFeatures_management(extractedBuffers,r'C:\NWM\scratch.gdb\aa_buff_ab')#$
##                arcpy.MakeFeatureLayer_management(extractedBuffers,"extractedBuffers")
##            exit()#$

            ##CREATE LIST WITH WETLAND ID VALUES OF WHICH THEIR WATERSHEDS ARE COMPLETELY WITHIN THE BUFFER
            arcpy.AddMessage ("\n>>> Identifying watersheds located entirely within their 200 m buffer and/or wetland ...")
            arcpy.AddMessage ("     - Identifying watersheds located entirely within the 200 m buffer ...")
            arcpy.SelectLayerByAttribute_management("fcUnion","CLEAR_SELECTION") 

            #Create list of watershed located entirely withinthe buffer
            wshedInsideBufferList = []
            insideWetlList = []
            wshedOutside = [] #list with 'featOID' values of all watershed potions outside of buffers
            wshedWithin = [] #list with 'featOID' values of all watershed potions inside of buffers
            with arcpy.da.SearchCursor ("fcUnion", ["featOID","featID_buff","featID_org"]) as cursor: 
                for row in cursor:
                    if row[0] == 0:
                        if row[1] == 0 and row[2] <> 0:
                            if row[2] not in wshedOutside:
                                if row[2] != 0:
                                    wshedOutside.append(row[2])
                    if row[1] == row[2]:
                        if row[1] not in wshedWithin:
                             if row[1] != 0:
                                wshedWithin.append(row[1])
            wshedInsideBufferList = [item for item in wshedWithin if item not in wshedOutside]

            if len(wshedInsideBufferList) > 0:
                arcpy.AddMessage ("     - Identifying watersheds located entirely within the wetland ...")
                wshedOutside = [] #list with 'featOID' values of all watershed potions outside of wetlands
                wshedWithin = [] #list with 'featOID' values of all watershed potions inside of wetlands
                #difference between 
                with arcpy.da.SearchCursor ("fcUnion", ["featOID","featID_org"]) as cursor: 
                    for row in cursor:
                        if row[0] == 0 and row[1] <> 0:
                            if row[1] not in wshedOutside:
                                wshedOutside.append(row[1])
                        if row[0] != 0:
                            if row[0] == row[1]:
                                if row[0] not in wshedWithin:
                                    wshedWithin.append(row[0])
                insideWetlList = [item for item in wshedWithin if item not in wshedOutside]

            #the selection selcts watershed entirely within the buffer, but not watersheds entirely withon the wetland
            if len(wshedInsideBufferList) > 0:
                arcpy.AddMessage ("     - Creating feature class of watershed located entirely within the 200 m buffer ...")
                for i in wshedInsideBufferList:
                    sql = "featID_buff = " + str(i) + " and featID_org = " + str(i)
                    arcpy.SelectLayerByAttribute_management("fcUnion","ADD_TO_SELECTION",sql) #the selection selcts watershed entirely within the buffer, but not watersheds entirely withon the wetland
                arcpy.Dissolve_management ("fcUnion", wshedDissInside, ["featID_buff","featID_org"], "", "MULTI_PART", "") #'wshedDissInside' is the total watershed excluding the wetland (it includes the buffer as the total watershed is located within the buffer))
                arcpy.SelectLayerByAttribute_management("fcUnion","CLEAR_SELECTION")
##                arcpy.CopyFeatures_management(wshedDissInside,r'C:\NWM\scratch.gdb\wshedDissInside')#$

            if len(insideWetlList) > 0:
                arcpy.AddMessage ("     - Creating feature class of watershed located entirely within the wetland ...")
                for i in insideWetlList:
                    sql = "featOID = " + str(i)
                    arcpy.SelectLayerByAttribute_management("fcUnion","ADD_TO_SELECTION",sql) #the selection selcts watershed entirely within the buffer, but not watersheds entirely withon the wetland
                arcpy.Dissolve_management ("fcUnion", wshedDissInsideWetl, ["featOID",], "", "MULTI_PART", "") #'wshedDissInsideWetl' is the total wetland exluding the buffer and watershed (as bothe are located within the wetland)
                arcpy.SelectLayerByAttribute_management("fcUnion","CLEAR_SELECTION")
##                arcpy.CopyFeatures_management(wshedDissInsideWetl,r'C:\NWM\scratch.gdb\wshedDissInsideWetl')#$

            wshedInsideBufferList = wshedInsideBufferList + insideWetlList #'wshedInsideBufferList' must contain watersheds located entire within the buffer as well as watersheds located entirely within the wetland

            if len(wshedInsideBufferList) > 0:
                wshedInsideBufferList.sort()
                txt = ", ".join(str(x) for x in wshedInsideBufferList)
                arcpy.AddWarning ("      - Wetlands with watershed entirely within its buffer, field 'featOID': " + txt)
            else:
                arcpy.AddMessage ("      - All watersheds extend beyond their 200 m buffer")

            if len(insideWetlList) > 0:
                insideWetlList.sort()
                txt = ", ".join(str(x) for x in insideWetlList)
                arcpy.AddWarning ("      - Wetlands with watershed entirely within the wetland, field 'featOID': " + txt)
            else:
                arcpy.AddMessage ("      - All watersheds extend beyond their wetland")

            #Iterative repair geometry
            arcpy.AddMessage ("     - Iteratively repairing geometry ...")
            #fcList = [wetlDiss,bufferDiss,wshedDiss,wshedDiss_excl,wshedDissInside,wshedDissInsideWetl]
            fcList = [wetlDiss,bufferDiss,wshedDiss,wshedDissInside,wshedDissInsideWetl]
            featureCount = len(fcList) # To manage the progress bar
            arcpy.SetProgressor ("step", "Iteratively repairing geometry ...", 0, featureCount, 1)                
            for fc in fcList:
                if arcpy.Exists(fc):
                    feature = fc
                    arcpy.CheckGeometry_management ([feature, ], geometryTable)
                    geomCounter = int(arcpy.GetCount_management(geometryTable).getOutput(0))
                    geomCheck = 0
                    while int(arcpy.GetCount_management(geometryTable).getOutput(0)) > 0 and geomCounter != geomCheck:
                        geomCheck = geomCounter
                        arcpy.RepairGeometry_management (feature, "DELETE_NULL")
                        arcpy.CheckGeometry_management ([feature, ], geometryTable)
                        geomCounter = int(arcpy.GetCount_management(geometryTable).getOutput(0))
                arcpy.SetProgressorPosition()
            arcpy.ResetProgressor()
            arcpy.SetProgressorLabel("Calculating PES: Level 1A ...")

            #Create dictionaries to hold all the data
            wetlandAreaDic = {}
            bufferAreaDic = {}
            wshedAreaDic = {}
            wshedAreaDic_excl = {}
            wshedAreaDicInsideBuff = {}
            wshedAreaDicInsideWetl = {}

            arcpy.AddMessage ("\n>>> Calculating feature sizes ...")
            #Get the wetland area in hectares
            wetlOIDList = [] #Create a list with all the wetland OID values
            arcpy.AddMessage ("     - For wetlands ...")
            with arcpy.da.SearchCursor(wetlDiss,["featOID","SHAPE@AREA"]) as cursor:
                for row in cursor:
                    wetlOIDList.append(row[0])
                    wetlandArea_ha = row[1] / 10000 # Divide by 1 000 000 to calculate km2 / divide by 10 000 to calculate ha
                    wetlandAreaDic[row[0]] = wetlandArea_ha
##            arcpy.AddMessage ("\nwetlandAreaDic: " + str(wetlandAreaDic))#$

            #Get the buffer area in hectares
            arcpy.AddMessage ("     - For buffers ...")
            with arcpy.da.SearchCursor(bufferDiss,["featID_buff","SHAPE@AREA"]) as cursor:
                for row in cursor:
                    if row[0] not in wshedInsideBufferList: #Enter only if the watershed extends beyond the buffer
                        bufferArea_ha = row[1] / 10000 # Divide by 1 000 000 to calculate km2 / divide by 10 000 to calculate ha
                        bufferAreaDic[row[0]] = bufferArea_ha
##            arcpy.AddMessage ("\nbufferAreaDic: " + str(bufferAreaDic))#$

            #Get the watershed area in hectares (including wetland and buffer)
            arcpy.AddMessage ("     - For watersheds (including wetland and buffer) ...")
            with arcpy.da.SearchCursor(wshedDiss,["featID_org","SHAPE@AREA"]) as cursor:
                for row in cursor:
                    watershedArea_ha = row[1] / 10000 # Divide by 1 000 000 to calculate km2 / divide by 10 000 to calculate ha
                    wshedAreaDic[row[0]] = watershedArea_ha
##            arcpy.AddMessage ("\nwshedAreaDic: " + str(wshedAreaDic))#$

            #Get the watershed area in hectares (excluding wetland and buffer)
            arcpy.AddMessage ("     - For watersheds (excluding wetland and buffer) ...")
            with arcpy.da.SearchCursor(wshedDiss,["featID_org","SHAPE@AREA"]) as cursor:
                for row in cursor:
                    wetlArea = 0
                    buffArea = 0
                    watershedArea_ha = row[1] / 10000 # Divide by 1 000 000 to calculate km2 / divide by 10 000 to calculate ha
                    if row[0] in wetlandAreaDic:
                        wetlArea = wetlandAreaDic[row[0]]
                    if row[0] in bufferAreaDic:
                        buffArea = bufferAreaDic[row[0]]
                    minWetlBuffArea = wetlArea + buffArea
                    watershedArea_ha = watershedArea_ha - minWetlBuffArea
                    wshedAreaDic_excl[row[0]] = watershedArea_ha
##            arcpy.AddMessage ("\nwshedAreaDic_excl: " + str(wshedAreaDic_excl))#$

            #Get the watershed area in hectares (enirely within buffer) 
            if len(wshedInsideBufferList) > 0:
                arcpy.AddMessage ("     - For watersheds (watershed entirely within buffer)...")
                with arcpy.da.SearchCursor(wshedDissInside,["featID_org","SHAPE@AREA"]) as cursor:
                    for row in cursor:
                        wetlArea = 0
                        watershedArea_ha = row[1] / 10000 # Divide by 1 000 000 to calculate km2 / divide by 10 000 to calculate ha
                        if row[0] in wetlandAreaDic:
                            wetlArea = wetlandAreaDic[row[0]]
                        watershedArea_ha = watershedArea_ha - wetlArea
                        wshedAreaDicInsideBuff[row[0]] = watershedArea_ha
##            arcpy.AddMessage ("\nwshedAreaDicInsideBuff: " + str(wshedAreaDicInsideBuff))#$

            #Get the watershed area in hectares (enirely within wetland)
            if len(insideWetlList) > 0:
                #Get the watershed area in hectares (enirely within wetland)
                arcpy.AddMessage ("     - For watersheds (watershed entirely within wetland)...")
                with arcpy.da.SearchCursor(wshedDissInsideWetl,["featOID","SHAPE@AREA"]) as cursor:
                    for row in cursor:
                        #watershedArea_ha = row[1] / 10000 # Divide by 1 000 000 to calculate km2 / divide by 10 000 to calculate ha
                        watershedArea_ha = wetlandAreaDic[row[0]]
                        wshedAreaDicInsideWetl[row[0]] = watershedArea_ha
##            arcpy.AddMessage ("\nwshedAreaDicInsideWetl: " + str(wshedAreaDicInsideWetl))#$

            #Get the area of differenmt land cover classes
            lcPolygon = scratchWorkspace + "\\lcPolygon"
            lcPolygonClip = scratchWorkspace + "\\lcPolygonClip"
            fcUnion_tmp = scratchWorkspace + "\\fcUnion_tmp"

            wetlLCareaDic = {} #nested dictionary with featOID as outer key and land cover class and area as inner key and value
            buffLCareaDic = {} #nested dictionary with featID_buff as outer key and land cover class and area as inner key and value
            wshedLCareaDic = {} #nested dictionary with featID_org as outer key and land cover class and area as inner key and value
            wshedInsideLCareaDic = {} #nested dictionary with featID_org as outer key and land cover class and area as inner key and value
            wshedInsideWetlLCareaDic = {} #nested dictionary with featID_org as outer key and land cover class and area as inner key and value

            #Convert land cover to vector
##            arcpy.AddMessage ("\nlcField: " + str(lcField))#$
            arcpy.AddMessage ("     - Converting land cover to polygons ...")
            arcpy.RasterToPolygon_conversion (landcover, lcPolygon, "NO_SIMPLIFY",lcField)
##            arcpy.CopyFeatures_management(lcPolygon,r'C:\NWM\scratch.gdb\lcPolygon')#$
            
            arcpy.AddMessage ("     - Creating feature area tables: Wetlands ...")
            #Clip land cover to union extent
            arcpy.AddMessage ("      - Clipping land cover to wetland features extent ...")
            arcpy.Clip_analysis (lcPolygon, wetlDiss, lcPolygonClip)
            arcpy.AddMessage ("      - Creating union of land cover with wetland features ...")
            arcpy.Union_analysis ([wetlDiss,lcPolygonClip], fcUnion_tmp)
##            arcpy.CopyFeatures_management(fcUnion_tmp,r'C:\NWM\scratch.gdb\fcUnion_tmp_wetl')#$

            with arcpy.da.SearchCursor (fcUnion_tmp, ["featOID","SHAPE@AREA","gridcode"]) as cursor: 
                for row in cursor:
                    if row[0] in allWetlList:
                        if row[0] in wetlLCareaDic:
                            if row[2] in wetlLCareaDic[row[0]]:
                                area = wetlLCareaDic[row[0]][row[2]]
                                area = area + row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                                wetlLCareaDic[row[0]][row[2]] = area
                            else:
                                area = row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                                wetlLCareaDic[row[0]][row[2]] = area
                        else:
                            area = row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                            wetlLCareaDic[row[0]] = {}
                            wetlLCareaDic[row[0]][row[2]] = area

            arcpy.AddMessage ("     - Creating feature area tables: Buffers...")
            arcpy.AddMessage ("      - Clipping land cover to buffer features extent ...")
##            arcpy.CopyFeatures_management(lcPolygon,r'C:\NWM\scratch.gdb\lcPolygon') #$
##            arcpy.CopyFeatures_management(bufferDiss,r'C:\NWM\scratch.gdb\bufferDiss') #$
            arcpy.Clip_analysis (lcPolygon, bufferDiss, lcPolygonClip)
##            arcpy.CopyFeatures_management(lcPolygonClip,r'C:\NWM\scratch.gdb\lcPolygonClip') #$
            arcpy.AddMessage ("      - Creating union of land cover with buffer features ...")
            arcpy.Union_analysis ([bufferDiss,lcPolygonClip], fcUnion_tmp)
##            arcpy.CopyFeatures_management(fcUnion_tmp,r'C:\NWM\scratch.gdb\fcUnion_tmp') #$
##            arcpy.CopyFeatures_management(fcUnion_tmp,r'C:\NWM\scratch.gdb\fcUnion_tmp_buff')#$
            
            with arcpy.da.SearchCursor (fcUnion_tmp, ["featID_buff","SHAPE@AREA","gridcode"]) as cursor: 
                for row in cursor:
                    if row[0] in allWetlList:
                        if row[0] in buffLCareaDic:
                            if row[2] in buffLCareaDic[row[0]]:
                                area = buffLCareaDic[row[0]][row[2]]
                                area = area + row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                                buffLCareaDic[row[0]][row[2]] = area
                            else:
                                area = row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                                buffLCareaDic[row[0]][row[2]] = area
                        else:
                            area = row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                            buffLCareaDic[row[0]] = {}
                            buffLCareaDic[row[0]][row[2]] = area

            arcpy.AddMessage ("     - Creating feature area tables: Watersheds ...")
            arcpy.AddMessage ("      - Clipping land cover to watershed features extent ...")
            arcpy.Clip_analysis (lcPolygon, wshedDiss, lcPolygonClip)
            arcpy.AddMessage ("      - Creating union of land cover with watershed features ...")
            arcpy.Union_analysis ([wshedDiss,lcPolygonClip], fcUnion_tmp)
##            arcpy.CopyFeatures_management(fcUnion_tmp,r'C:\NWM\scratch.gdb\fcUnion_tmp_wshed')#$
            
            with arcpy.da.SearchCursor (fcUnion_tmp, ["featID_org","SHAPE@AREA","gridcode"]) as cursor: 
                for row in cursor:
                    if row[0] in allWetlList:
                        if row[0] in wshedLCareaDic:
                            if row[2] in wshedLCareaDic[row[0]]:
                                area = wshedLCareaDic[row[0]][row[2]]
                                area = area + row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                                wshedLCareaDic[row[0]][row[2]] = area
                            else:
                                area = row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                                wshedLCareaDic[row[0]][row[2]] = area
                        else:
                            area = row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                            wshedLCareaDic[row[0]] = {}
                            wshedLCareaDic[row[0]][row[2]] = area

            if len(wshedInsideBufferList) > 0: #for watersheds entirely within buffer
                arcpy.AddMessage ("     - Creating feature area tables: Watersheds entirely within buffer ...")
                arcpy.AddMessage ("      - Clipping land cover to watershed within buffer features extent ...")
                arcpy.Clip_analysis (lcPolygon, wshedDissInside, lcPolygonClip)
                arcpy.AddMessage ("      - Creating union of land cover with watershed within buffer features ...")
                arcpy.Union_analysis ([wshedDissInside,lcPolygonClip], fcUnion_tmp)
##                arcpy.CopyFeatures_management(fcUnion_tmp,r'C:\NWM\scratch.gdb\fcUnion_tmp_inbuffer')#$
                
                with arcpy.da.SearchCursor (fcUnion_tmp, ["featID_buff","SHAPE@AREA","gridcode"]) as cursor: 
                    for row in cursor:
                        if row[0] in wshedInsideBufferList:
                            if row[0] in wshedInsideLCareaDic:
                                if row[2] in wshedInsideLCareaDic[row[0]]:
                                    area = wshedInsideLCareaDic[row[0]][row[2]]
                                    area = area + row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                                    wshedInsideLCareaDic[row[0]][row[2]] = area
                                else:
                                    area = row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                                    wshedInsideLCareaDic[row[0]][row[2]] = area
                            else:
                                area = row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                                wshedInsideLCareaDic[row[0]] = {}
                                wshedInsideLCareaDic[row[0]][row[2]] = area

            if len(insideWetlList) > 0: #for watersheds entirely within buffer
                arcpy.AddMessage ("     - Creating feature area tables: Watersheds entirely within wetland ...")
                arcpy.AddMessage ("      - Clipping land cover to watershed within wetland features extent ...")
                arcpy.Clip_analysis (lcPolygon, wshedDissInsideWetl, lcPolygonClip)
                arcpy.AddMessage ("      - Creating union of land cover with watershed within wetland features ...")
                arcpy.Union_analysis ([wshedDissInsideWetl,lcPolygonClip], fcUnion_tmp)
##                arcpy.CopyFeatures_management(fcUnion_tmp,r'C:\NWM\scratch.gdb\fcUnion_tmp_inwetl')#$
                
                with arcpy.da.SearchCursor (fcUnion_tmp, ["featOID","SHAPE@AREA","gridcode"]) as cursor: 
                    for row in cursor:
                        if row[0] in insideWetlList:
                            if row[0] in wshedInsideWetlLCareaDic:
                                if row[2] in wshedInsideWetlLCareaDic[row[0]]:
                                    area = wshedInsideWetlLCareaDic[row[0]][row[2]]
                                    area = area + row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                                    wshedInsideWetlLCareaDic[row[0]][row[2]] = area
                                else:
                                    area = row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                                    wshedInsideWetlLCareaDic[row[0]][row[2]] = area
                            else:
                                area = row[1]/10000 # Devide by 1000000 to calculate km2 / devide by 10000 to calculate ha
                                wshedInsideWetlLCareaDic[row[0]] = {}
                                wshedInsideWetlLCareaDic[row[0]][row[2]] = area

##            arcpy.AddMessage ("\nwetlLCareaDic: " + str(wetlLCareaDic))#$
##            arcpy.AddMessage ("\nbuffLCareaDic: " + str(buffLCareaDic))#$
##            arcpy.AddMessage ("\nwshedLCareaDic: " + str(wshedLCareaDic))#$
##            arcpy.AddMessage ("\nwshedInsideLCareaDic: " + str(wshedInsideLCareaDic))#$
##            arcpy.AddMessage ("\nwshedInsideWetlLCareaDic: " + str(wshedInsideWetlLCareaDic))#$

            ##CREATE the TABLES WITH LAND COVER CLASS AREAS
            arcpy.AddMessage ("\n>>> Creating tables with land cover class areas ...")

            lcWetlandsTable = scratchWorkspace + "\\lcWetlandsTable"
            lcBufferTable = scratchWorkspace + "\\lcBufferTable"
            lcWshedTable = scratchWorkspace + "\\lcWshedTable"
            lcWshedTable_inside = scratchWorkspace + "\\lcWshedTable_inside"
            lcWshedTable_insideWetl = scratchWorkspace + "\\lcWshedTable_insideWetl"
            
            arcpy.AddMessage ("     - For wetlands ...")
            #Create list with WETLAND land cover table fields
            tableFields = []
            for i in lcList:
                val = "PES_C_" + str(i)
                if val not in tableFields:
                    tableFields.append(val)
            tableFields.sort()
##                arcpy.AddMessage ("\ntableFields: " + str(tableFields))#$
            
            #reate the wetlands table and add land cover category fields to the table
            arcpy.CreateTable_management (scratchWorkspace, "lcWetlandsTable")
            arcpy.AddField_management(lcWetlandsTable, "FEATOID", "LONG")
            for lcField in tableFields:
                arcpy.AddField_management(lcWetlandsTable, lcField, "DOUBLE")
##            arcpy.CopyRows_management(scratchWorkspace + "\\lcWetlandsTable",r'C:\NWM\scratch.gdb\lcWetlandsTable_1')#$

            #Get the order of the land cover categories in the table
            orderTable = []
            for item in tableFields:
                item = item.replace("PES_C_","")
                orderTable.append(item)
##                arcpy.AddMessage ("\norderTable: " + str(orderTable))#$
            tableFields.insert(0,"FEATOID")
##                arcpy.AddMessage ("\ntableFields: " + str(tableFields))#$

            for featKey in wetlLCareaDic:
                rowList = []
##                    arcpy.AddMessage ("\nfeatKey: " + str(featKey))#$
##                    arcpy.AddMessage ("\nwetlLCareaDic: " + str(wetlLCareaDic[featKey]))#$
                for lcCat in orderTable:
##                        arcpy.AddMessage ("lcCat: " + str(lcCat))#$
                    if int(lcCat) in wetlLCareaDic[featKey]:
                        rowList.append(wetlLCareaDic[featKey][int(lcCat)])
                    else:
                        rowList.append(0)
##                    arcpy.AddMessage ("\nrowList: " + str(rowList))#$

                lc1 = rowList[0]
                lc10 = rowList[1]
                lc11 = rowList[2]
                lc12 = rowList[3]
                lc13 = rowList[4]
                lc14 = rowList[5]
                lc15 = rowList[6]
                lc16 = rowList[7]
                lc17 = rowList[8]
                lc18 = rowList[9]
                lc19 = rowList[10]
                lc2 = rowList[11]
                lc3 = rowList[12]
                lc4 = rowList[13]
                lc5 = rowList[14]
                lc6 = rowList[15]
                lc7 = rowList[16]
                lc8 = rowList[17]
                lc9 = rowList[18]

                with arcpy.da.InsertCursor (lcWetlandsTable, tableFields) as iCursor:
                    iCursor.insertRow((featKey,lc1,lc10,lc11,lc12,lc13,lc14,lc15,lc16,lc17,lc18,lc19,lc2,lc3,lc4,lc5,lc6,lc7,lc8,lc9))
##            arcpy.CopyRows_management(scratchWorkspace + "\\lcWetlandsTable",r'C:\NWM\scratch.gdb\lcWetlandsTable_2')#$

            #Create list with BUFFER land cover table fields
            arcpy.AddMessage ("     - For buffers ...")
            tableFields = []
            for i in lcList:
                val = "PES_C_" + str(i)
                if val not in tableFields:
                    tableFields.append(val)
            tableFields.sort()
##                arcpy.AddMessage ("\ntableFields: " + str(tableFields))#$
            
            #create the buffer table and add land cover category fields to the table
            arcpy.CreateTable_management (scratchWorkspace, "lcBufferTable")
            arcpy.AddField_management(lcBufferTable, "FEATID_BUFF", "LONG")
            for lcField in tableFields:
                arcpy.AddField_management(lcBufferTable, lcField, "DOUBLE")
##            arcpy.CopyRows_management(scratchWorkspace + "\\lcBufferTable",r'C:\NWM\scratch.gdb\lcBufferTable_1')#$

            #Get the order of the land cover categories in the table
            orderTable = []
            for item in tableFields:
                item = item.replace("PES_C_","")
                orderTable.append(item)
##                arcpy.AddMessage ("\norderTable: " + str(orderTable))#$
            tableFields.insert(0,"FEATID_BUFF")
##                arcpy.AddMessage ("\ntableFields: " + str(tableFields))#$

            for featKey in buffLCareaDic:
                rowList = []
##                    arcpy.AddMessage ("\nfeatKey: " + str(featKey))#$
##                    arcpy.AddMessage ("\nbuffLCareaDic: " + str(buffLCareaDic[featKey]))#$
                for lcCat in orderTable:
##                        arcpy.AddMessage ("lcCat: " + str(lcCat))#$
                    if int(lcCat) in buffLCareaDic[featKey]:
                        rowList.append(buffLCareaDic[featKey][int(lcCat)])
                    else:
                        rowList.append(0)
##                    arcpy.AddMessage ("\nrowList: " + str(rowList))#$

                lc1 = rowList[0]
                lc10 = rowList[1]
                lc11 = rowList[2]
                lc12 = rowList[3]
                lc13 = rowList[4]
                lc14 = rowList[5]
                lc15 = rowList[6]
                lc16 = rowList[7]
                lc17 = rowList[8]
                lc18 = rowList[9]
                lc19 = rowList[10]
                lc2 = rowList[11]
                lc3 = rowList[12]
                lc4 = rowList[13]
                lc5 = rowList[14]
                lc6 = rowList[15]
                lc7 = rowList[16]
                lc8 = rowList[17]
                lc9 = rowList[18]

                with arcpy.da.InsertCursor (lcBufferTable, tableFields) as iCursor:
                    iCursor.insertRow((featKey,lc1,lc10,lc11,lc12,lc13,lc14,lc15,lc16,lc17,lc18,lc19,lc2,lc3,lc4,lc5,lc6,lc7,lc8,lc9))
##            arcpy.CopyRows_management(scratchWorkspace + "\\lcBufferTable",r'C:\NWM\scratch.gdb\lcBufferTable_2')#$


            #Create list with WATERSHED land cover table fields
            arcpy.AddMessage ("     - For watersheds ...")
            tableFields = []
            for i in lcList:
                val = "PES_C_" + str(i)
                if val not in tableFields:
                    tableFields.append(val)
            tableFields.sort()
##            arcpy.AddMessage ("\ntableFields: " + str(tableFields))#$
            
            #create the buffer table and add land cover category fields to the table
            arcpy.CreateTable_management (scratchWorkspace, "lcWshedTable")
            arcpy.AddField_management(lcWshedTable, "FEATID_ORG", "LONG")
##            arcpy.AddMessage ("tableFields: " + str(tableFields))#$
            for lcField in tableFields:
                arcpy.AddField_management(lcWshedTable, lcField, "DOUBLE")
##            arcpy.CopyRows_management(scratchWorkspace + "\\lcWshedTable",r'C:\NWM\scratch.gdb\lcWshedTable_1')#$

            #Get the order of the land cover categories in the table
            orderTable = []
            for item in tableFields:
                item = item.replace("PES_C_","")
                orderTable.append(item)
##                arcpy.AddMessage ("\norderTable: " + str(orderTable))#$
            tableFields.insert(0,"FEATID_ORG")
##                arcpy.AddMessage ("\ntableFields: " + str(tableFields))#$

            for featKey in wshedLCareaDic:
                rowList = []
##                    arcpy.AddMessage ("\nfeatKey: " + str(featKey))#$
##                    arcpy.AddMessage ("\nwshedLCareaDic: " + str(wshedLCareaDic[featKey]))#$
                for lcCat in orderTable:
##                        arcpy.AddMessage ("lcCat: " + str(lcCat))#$
                    if int(lcCat) in wshedLCareaDic[featKey]:
                        rowList.append(wshedLCareaDic[featKey][int(lcCat)])
                    else:
                        rowList.append(0)
##                    arcpy.AddMessage ("\nrowList: " + str(rowList))#$

                lc1 = rowList[0]
                lc10 = rowList[1]
                lc11 = rowList[2]
                lc12 = rowList[3]
                lc13 = rowList[4]
                lc14 = rowList[5]
                lc15 = rowList[6]
                lc16 = rowList[7]
                lc17 = rowList[8]
                lc18 = rowList[9]
                lc19 = rowList[10]
                lc2 = rowList[11]
                lc3 = rowList[12]
                lc4 = rowList[13]
                lc5 = rowList[14]
                lc6 = rowList[15]
                lc7 = rowList[16]
                lc8 = rowList[17]
                lc9 = rowList[18]

                with arcpy.da.InsertCursor (lcWshedTable, tableFields) as iCursor:
                    iCursor.insertRow((featKey,lc1,lc10,lc11,lc12,lc13,lc14,lc15,lc16,lc17,lc18,lc19,lc2,lc3,lc4,lc5,lc6,lc7,lc8,lc9))
##            arcpy.CopyRows_management(lcWshedTable,r'C:\NWM\scratch.gdb\lcWshedTable_2')#$



####            Adjust the area used to calcuilate the magnitude of impact scores
##            #Get the total area of all watershed land cover classes
##            totLCdic = {}
##            totLCfields = [field.name for field in arcpy.ListFields(lcWshedTable)]
##            idUID = arcpy.Describe(lcWshedTable).oidFieldName
####            arcpy.AddMessage ("idUID: " + str(idUID))#$
##            #Remove the ID field
##            for field in totLCfields:
##                if field == idUID:
##                    totLCfields.remove(idUID)
##
##            #Determine te fields with natural and not-natural land cover classes
##            lcOrderDic = {}
##            counter = 0
####            arcpy.AddMessage ("\n totLCfields: " + str(totLCfields))#$
##            for field in totLCfields:
##                if "PES_C_" in field:
##                    item = int(field.replace("PES_C_",""))
##                    lcOrderDic[counter] = item
##                counter += 1
####            arcpy.AddMessage ("\n lcOrderDic: " + str(lcOrderDic))#$
##
####            arcpy.AddMessage ("totLCfields: " + str(totLCfields))#$
##            nFields = len(totLCfields)
####            arcpy.AddMessage ("nFields: " + str(nFields))#$
##            if nFields > 0:
####                arcpy.AddMessage ("totLCfields: " + str(totLCfields))#$
####                arcpy.CopyRows_management(lcWshedTable,r'C:\NWM\scratch.gdb\lcWshedTable_3')#$
##                with arcpy.da.SearchCursor (lcWshedTable, totLCfields) as cursor:
####                with arcpy.da.SearchCursor (lcWshedTable, ['FEATID_ORG', 'PES_C_1', 'PES_C_10', 'PES_C_11', 'PES_C_12', 'PES_C_13', 'PES_C_14', 'PES_C_15', 'PES_C_16', 'PES_C_17', 'PES_C_18', 'PES_C_19', 'PES_C_2', 'PES_C_3', 'PES_C_4', 'PES_C_5', 'PES_C_6', 'PES_C_7', 'PES_C_8', 'PES_C_9']) as cursor:
##                    for row in cursor:
##                        totAreaNat = 0 #Variable to keep the total of natural land cover classes
##                        totAreaNotNat = 0 #Variable to keep the total of not-natural land cover classes
##                        n = 1
####                        arcpy.AddMessage ("n1: " + str(n))#$
##                        while n < nFields:
####                            arcpy.AddMessage ("row[n]: " + str(row[n]))#$
##                            lcType = lcOrderDic[n]
##                            if lcType == 1 or lcType == 3:
##                                totAreaNat += row[n]
##                            else:
##                                totAreaNotNat += row[n]
##                            n += 1
####                            arcpy.AddMessage ("n2: " + str(n))#$
##                        totLCdic[row[0]] = [totAreaNat,totAreaNotNat,totAreaNat + totAreaNotNat,(totAreaNat/(totAreaNat + totAreaNotNat))*100]
##
##                #Update the watershed area as informed by the total area of transformed land uses 
####                arcpy.AddMessage ("\n totLCdic: " + str(totLCdic))#$
##                arcpy.AddMessage ("\n wshedAreaDic: " + str(wshedAreaDic))#$
##
##                adjustedNatDic = {}
##                for id in totLCdic:
####                    values = totLCdic[id]
####                    wshedAreaDic[id] = values[1] #assume for not natural land cover classes that the total watershed = not natural watershed, irrespective if natural area > 10% of total area or not
##
##                    
####                    arcpy.AddMessage ("\n id: " + str(id))#$
##                    values = totLCdic[id]
####                    arcpy.AddMessage ("values: " + str(values))#$
##                    percValue = values[3]
####                    arcpy.AddMessage ("percValue: " + str(percValue))#$
##                    if percValue > 10: #i.e. the total natural land cover class > 10% of the total watershed (excl wetl & buf) area
####                        #adjusted perc natural watershed area is the the not-natural + 10%
####                        newNatArea = (values[2]*0.1)+values[1] #if natural area > 10% of total area; new natural area = transformed area + 10% of total area
######                        arcpy.AddMessage ("newNatArea: " + str(newNatArea))#$
####                        adjustedNatDic[id] = newNatArea
##
##                        wshedAreaDic[id] = values[1] #if natural area > 10% of total area, assume for not natural land cover classes that the total watershed = total not-natural watershed
####                arcpy.AddMessage ("\n adjustedNatDic: " + str(adjustedNatDic))#$
##                arcpy.AddMessage ("\n wshedAreaDic: " + str(wshedAreaDic))#$
##
####                #Identify wetlands (featOID number) of wetlands of which their total natural land cover class > 10% of the total watershed (excl wetl & buf) area
######                adjustedNatList = []
####                for id in wshedAreaDic:
####                    if id in adjustedNatDic:
####                        orgValue = wshedAreaDic[id]
####                        adjValue = adjustedNatDic[id]
####                        if orgValue - adjValue > 0:
####                            adjustedNatList.append(id)
####                arcpy.AddMessage ("\n adjustedNatList: " + str(adjustedNatList))#$
##                
####            else:
####                with arcpy.da.SearchCursor (lcWshedTable, totLCfields) as cursor:
####                    totLCdic[row[0]] = 0.0
####
####            exit()#$

            if len(wshedInsideBufferList) > 0: #for watersheds entirely within buffer
                arcpy.AddMessage ("     - For watersheds completely within the buffer ...")
                #Create list with WATERSHED INSIDE BUFFER land cover table fields
                tableFields = []
                for i in lcList:
                    val = "PES_C_" + str(i)
                    if val not in tableFields:
                        tableFields.append(val)
                tableFields.sort()
##                arcpy.AddMessage ("\ntableFields: " + str(tableFields))#$
                
                #create the buffer table and add land cover category fields to the table
                arcpy.CreateTable_management (scratchWorkspace, "lcWshedTable_inside")
                arcpy.AddField_management(lcWshedTable_inside, "FEATID_ORG", "LONG")
                for lcField in tableFields:
                    arcpy.AddField_management(lcWshedTable_inside, lcField, "DOUBLE")
##                arcpy.CopyRows_management(scratchWorkspace + "\\lcWshedTable_inside",r'C:\NWM\scratch.gdb\lcWshedTable_inside_1')#$

                #Get the order of the land cover categories in the table
                orderTable = []
                for item in tableFields:
                    item = item.replace("PES_C_","")
                    orderTable.append(item)
##                    arcpy.AddMessage ("\norderTable: " + str(orderTable))#$
                tableFields.insert(0,"FEATID_ORG")
##                    arcpy.AddMessage ("\ntableFields: " + str(tableFields))#$

                for featKey in wshedInsideLCareaDic:
                    rowList = []
##                        arcpy.AddMessage ("\nfeatKey: " + str(featKey))#$
##                        arcpy.AddMessage ("\nwshedInsideLCareaDic: " + str(wshedInsideLCareaDic[featKey]))#$
                    for lcCat in orderTable:
##                            arcpy.AddMessage ("lcCat: " + str(lcCat))#$
                        if int(lcCat) in wshedInsideLCareaDic[featKey]:
                            rowList.append(wshedInsideLCareaDic[featKey][int(lcCat)])
                        else:
                            rowList.append(0)
##                        arcpy.AddMessage ("\nrowList: " + str(rowList))#$

                    lc1 = rowList[0]
                    lc10 = rowList[1]
                    lc11 = rowList[2]
                    lc12 = rowList[3]
                    lc13 = rowList[4]
                    lc14 = rowList[5]
                    lc15 = rowList[6]
                    lc16 = rowList[7]
                    lc17 = rowList[8]
                    lc18 = rowList[9]
                    lc19 = rowList[10]
                    lc2 = rowList[11]
                    lc3 = rowList[12]
                    lc4 = rowList[13]
                    lc5 = rowList[14]
                    lc6 = rowList[15]
                    lc7 = rowList[16]
                    lc8 = rowList[17]
                    lc9 = rowList[18]

                    with arcpy.da.InsertCursor (lcWshedTable_inside, tableFields) as iCursor:
                        iCursor.insertRow((featKey,lc1,lc10,lc11,lc12,lc13,lc14,lc15,lc16,lc17,lc18,lc19,lc2,lc3,lc4,lc5,lc6,lc7,lc8,lc9))
##                arcpy.CopyRows_management(lcWshedTable_inside,r'C:\NWM\scratch.gdb\lcWshedTable_inside_2')#$

            if len(insideWetlList) > 0: #for watersheds entirely within buffer
                arcpy.AddMessage ("     - For watersheds completely within the wetland ...")
                #Create list with WATERSHED INSIDE WETLAND land cover table fields
                tableFields = []
                for i in lcList:
                    val = "PES_C_" + str(i)
                    if val not in tableFields:
                        tableFields.append(val)
                tableFields.sort()
##                arcpy.AddMessage ("\ntableFields: " + str(tableFields))#$
                
                #create the buffer table and add land cover category fields to the table
                arcpy.CreateTable_management (scratchWorkspace, "lcWshedTable_insideWetl")
                arcpy.AddField_management(lcWshedTable_insideWetl, "FEATID_ORG", "LONG")
                for lcField in tableFields:
                    arcpy.AddField_management(lcWshedTable_insideWetl, lcField, "DOUBLE")
##                arcpy.CopyRows_management(scratchWorkspace + "\\lcWshedTable_insideWetl",r'C:\NWM\scratch.gdb\lcWshedTable_insideWetl_1')#$

                #Get the order of the land cover categories in the table
                orderTable = []
                for item in tableFields:
                    item = item.replace("PES_C_","")
                    orderTable.append(item)
##                    arcpy.AddMessage ("\norderTable: " + str(orderTable))#$
                tableFields.insert(0,"FEATID_ORG")
##                    arcpy.AddMessage ("\ntableFields: " + str(tableFields))#$

                for featKey in wshedInsideWetlLCareaDic:
                    rowList = []
##                        arcpy.AddMessage ("\nfeatKey: " + str(featKey))#$
##                        arcpy.AddMessage ("\nwshedInsideWetlLCareaDic: " + str(wshedInsideWetlLCareaDic[featKey]))#$
                    for lcCat in orderTable:
##                            arcpy.AddMessage ("lcCat: " + str(lcCat))#$
                        if int(lcCat) in wshedInsideWetlLCareaDic[featKey]:
                            rowList.append(wshedInsideWetlLCareaDic[featKey][int(lcCat)])
                        else:
                            rowList.append(0)
##                        arcpy.AddMessage ("\nrowList: " + str(rowList))#$

                    lc1 = rowList[0]
                    lc10 = rowList[1]
                    lc11 = rowList[2]
                    lc12 = rowList[3]
                    lc13 = rowList[4]
                    lc14 = rowList[5]
                    lc15 = rowList[6]
                    lc16 = rowList[7]
                    lc17 = rowList[8]
                    lc18 = rowList[9]
                    lc19 = rowList[10]
                    lc2 = rowList[11]
                    lc3 = rowList[12]
                    lc4 = rowList[13]
                    lc5 = rowList[14]
                    lc6 = rowList[15]
                    lc7 = rowList[16]
                    lc8 = rowList[17]
                    lc9 = rowList[18]

                    with arcpy.da.InsertCursor (lcWshedTable_insideWetl, tableFields) as iCursor:
                        iCursor.insertRow((featKey,lc1,lc10,lc11,lc12,lc13,lc14,lc15,lc16,lc17,lc18,lc19,lc2,lc3,lc4,lc5,lc6,lc7,lc8,lc9))
##                arcpy.CopyRows_management(lcWshedTable_insideWetl,r'C:\NWM\scratch.gdb\lcWshedTable_insideWetl_2')#$

##            exit()#$
            #Create a list of the land cover gridcodes (land cover classes)
            #lcFeatureClasses = [lcWetlandsTable, lcBufferTable, lcWshedTable_excl]
            lcFeatureClasses = [lcWetlandsTable, lcBufferTable, lcWshedTable]
            lcgrid = []
            for lcClass in lcFeatureClasses:
                fields = [field.name for field in arcpy.ListFields(lcClass)]
                for field in fields:
                    index = field.rfind("_")
                    if index > 0:
                        lcCat = field[index+1:]
                        try:
                            lcgrid.append(int(lcCat))
                        except:
                            pass
            lc_gridcodes = list(set(lcgrid)) #Remove the duplicates
            lc_gridcodes.sort() #Sort the list
##            arcpy.AddMessage ("\nlc_gridcodes: " + str(lc_gridcodes))#$

            ##Calculate the areas for the wetland land cover classes
            arcpy.AddMessage ("\n>>> Calculate land cover class areas ...")
                    
            arcpy.AddMessage ("     - Preparing data for analysis ...")
            arcpy.AddMessage ("      - Getting area table field names ...")
            #Get the prefix to the landcover class fields
            fields = [field.name for field in arcpy.ListFields(lcWetlandsTable)]
            for field in fields:
                index = field.rfind("_")
                if index > 0:
                    prefix = field[:index]
                    if prefix.lower() in lcField.lower():
                        lcp = prefix + "_"
                        break
##            arcpy.AddMessage ("\nlcp: " + str(lcp))#$

            #Get the feature areas from their land cover totals (else if using the featyure area then the percentage calculations are erronous)
            arcpy.AddMessage ("     - Caculating feature area from land cover for wetlands ...")
            arcpy.AddMessage ("      - For wetlands ...")
            PES_catFields = []
            fields = [field.name for field in arcpy.ListFields(lcWetlandsTable)]
            for field in fields:
                if lcp in field:
                    PES_catFields.append(field) # 'PES_catFields' = list with the landcover field in the area table (not all 20 lc PES categories are listed, only those with values)
            #PES_catFields.insert(0,wetlIDfield)
            PES_catFields.insert(0,"FEATOID")

            wetlandAreaDicLC = {} #Dictionary with lc area values
            featureCount = len(PES_catFields) # To manage the progress bar
            arcpy.SetProgressor ("step", "Calculating wetland land cover class areas ...", 0, featureCount, 1)
            with arcpy.da.SearchCursor (lcWetlandsTable, PES_catFields) as cursor: # 'lcWetlandsTableFields' = [OID,PES_cat_1, PES_cat_2, ...PES_cat_20] NB will not have all 20, only those with values
                for row in cursor:
                    area = 0.0
                    counter = 1
                    while counter < featureCount:
##                            nCells = row[counter]
                        area = area + row[counter]
                        counter += 1
##                        area = cellCount / 10000
                    wetlandAreaDicLC[row[0]] = area
                    arcpy.SetProgressorPosition()
            arcpy.ResetProgressor()
##            arcpy.AddMessage ("wetlandAreaDicLC: " + str(wetlandAreaDicLC))#$

            arcpy.AddMessage ("      - For buffers ...")
            PES_catFields = []
            fields = [field.name for field in arcpy.ListFields(lcBufferTable)]
            for field in fields:
                if lcp in field:
                    PES_catFields.append(field) # 'PES_catFields' = list with the landcover field in the area table (not all 20 lc PES categories are listed, only those with values)
            #PES_catFields.insert(0,"ORIG_FID")
            PES_catFields.insert(0,"FEATID_BUFF")

            bufferAreaDicLC = {} #Dictionary with lc area values
            featureCount = len(PES_catFields) # To manage the progress bar
            arcpy.SetProgressor ("step", "Calculating buffer cover class areas ...", 0, featureCount, 1)
            with arcpy.da.SearchCursor (lcBufferTable, PES_catFields) as cursor: # 'lcWetlandsTableFields' = [OID,PES_cat_1, PES_cat_2, ...PES_cat_20] NB will not have all 20, only those with values
                for row in cursor:
                    area = 0.0
                    counter = 1
                    while counter < featureCount:
##                            nCells = row[counter]
                        area = area + row[counter]
                        counter += 1
##                        area = cellCount / 10000
                    bufferAreaDicLC[row[0]] = area
                    arcpy.SetProgressorPosition()
            arcpy.ResetProgressor()
##            arcpy.AddMessage ("bufferAreaDicLC: " + str(bufferAreaDicLC))#$

            arcpy.AddMessage ("      - For watersheds ...")
            PES_catFields = []
            fields = [field.name for field in arcpy.ListFields(lcWshedTable)]
            for field in fields:
                if lcp in field:
                    PES_catFields.append(field) # 'PES_catFields' = list with the landcover field in the area table (not all 20 lc PES categories are listed, only those with values)
            PES_catFields.insert(0,"FEATID_ORG")

            wshedAreaDicLC = {} #Dictionary with lc area values
            featureCount = len(PES_catFields) # To manage the progress bar
            arcpy.SetProgressor ("step", "Calculating watershed land cover class areas ...", 0, featureCount, 1)
            with arcpy.da.SearchCursor (lcWshedTable, PES_catFields) as cursor: # 'lcWetlandsTableFields' = [OID,PES_cat_1, PES_cat_2, ...PES_cat_20] NB will not have all 20, only those with values
                for row in cursor:
                    area = 0.0
                    counter = 1
                    while counter < featureCount:
##                            nCells = row[counter]
                        area = area + row[counter]
                        counter += 1
##                        area = cellCount / 10000
                    wshedAreaDicLC[row[0]] = area
                    arcpy.SetProgressorPosition()
            arcpy.ResetProgressor()
            arcpy.SetProgressorLabel("Calculating Level 1A PES ...")
##            arcpy.AddMessage ("wshedAreaDicLC: " + str(wshedAreaDicLC))#$
            
            #Create a list with the landcover field in the area table (not all 20 lc PES categories are listed, only those with values)
            arcpy.AddMessage ("     - For wetlands ...")
            arcpy.AddMessage ("      - Creating reference list ...")
            PES_catFields = []
            fields = [field.name for field in arcpy.ListFields(lcWetlandsTable)]
            for field in fields:
                if lcp in field:
                    PES_catFields.append(field) # 'PES_catFields' = list with the landcover field in the area table (not all 20 lc PES categories are listed, only those with values)
##            arcpy.AddMessage ("PES_catFields: " + str(PES_catFields))#$

            arcpy.AddMessage ("      - Calculating wetland land cover class area and percentage ...")
            lcWetland = {} #Dictionary with lc area values
            lcWetland_area = {} #Dictionary with lc area values expressed as a percentage of the wetland total area
            featureCount = len(PES_catFields) # To manage the progress bar
            arcpy.SetProgressor ("step", "Calculating wetland land cover class areas ...", 0, featureCount, 1)
            for field in PES_catFields:
                index = field.rfind("_")
                lcCat = field[index+1:]
                with arcpy.da.SearchCursor (lcWetlandsTable, ["FEATOID",field]) as cursor: # 'lcWetlandsTableFields' = [OID,PES_cat_1, PES_cat_2, ...PES_cat_20] NB will not have all 20, only those with values
                    for row in cursor:
                        area = row[1]
##                            area = celCount / 10000
                        if area == 0.0:
                            area = 0
                        if row[0] in lcWetland:
                            lcWetland[row[0]].append([lcCat,area])
                        else:
                            lcWetland[row[0]] = [[lcCat,area]]
                            
                        #totalAreaWetland = wetlandAreaDic[row[0]]
                        totalAreaWetland = wetlandAreaDicLC[row[0]]

                        if totalAreaWetland != 0:
                            lcpercentage = (abs(area)/abs(totalAreaWetland))*100
                        else:
                            lcpercentage = 0.0
                        if row[0] in lcWetland_area:
                            lcWetland_area[row[0]].append([lcCat,lcpercentage])
                        else:
                            lcWetland_area[row[0]] = [[lcCat,lcpercentage]]
                arcpy.SetProgressorPosition()
            arcpy.ResetProgressor()
            arcpy.SetProgressorLabel("Calculating PES: Level 1A ...")
##            arcpy.AddMessage ("lcWetland: " + str(lcWetland))#$
##            arcpy.AddMessage ("lcWetland_area: " + str(lcWetland_area))#$

            # 217: [[u'2', 606425.0], [u'3', 1652825.0], [u'8', 1385975.0], [u'10', 1275.0], [u'17', 7025.0], [u'19', 0.0], [u'4', 562950.0]]}
            arcpy.AddMessage ("      - Calculating percent difference ...")
            featureCount = len(lcWetland) # To manage the progress bar
            arcpy.SetProgressor ("step", "Calculating percent difference ...", 0, featureCount, 1)
##                lcWetland.sort()
            for wetl_ID in lcWetland:
                try:
                    valuesList = lcWetland[wetl_ID]
                    totalLCarea = 0.0
                    for item in valuesList:
                        area = item[1]
                        totalLCarea += area
                        
                    totalAreaWetland = wetlandAreaDic[wetl_ID]
                    percDiff = (100 -((abs(totalLCarea) * 100) / abs(totalAreaWetland)))
                    if abs(percDiff) > int(errThreshold):
                        arcpy.AddWarning ("       - WARNING: Total wetland land cover area for wetland with '" + wetlandUID + "' " + str(wetl_ID) + " differs from wetland area by " + str(abs(percDiff)) + " percent.")
                        lcWetlandList.append(wetl_ID) 
                        lcWetlandVar = 1
                    lcWetlandListDic[wetl_ID] = abs(percDiff)
                    arcpy.SetProgressorPosition()
                except:
                    arcpy.SetProgressorPosition()
                    continue
            arcpy.ResetProgressor()
            arcpy.SetProgressorLabel("Calculating PES: Level 1A ...")

            arcpy.AddMessage ("     - For buffers ...")
            arcpy.AddMessage ("      - Creating reference list ...")
            PES_catFields = []
            fields = [field.name for field in arcpy.ListFields(lcBufferTable)]
            for field in fields:
                if lcp in field:
                    PES_catFields.append(field) # 'PES_catFields' = list with the landcover field in the area table (not all 20 lc PES categories are listed, only those with values)
            
            arcpy.AddMessage ("      - Calculating buffer land cover class area and percentage ...")
            lcBuffer = {} #Dictionary with lc buffer area values
            lcBuffer_area = {} #Dictionary with lc buffer area values expressed as a percentage of the wetland total area
            featureCount = len(PES_catFields) # To manage the progress bar
            arcpy.SetProgressor ("step", "Calculating buffer land cover class areas ...", 0, featureCount, 1)
            for field in PES_catFields:
                index = field.rfind("_")
                lcCat = field[index+1:]
                lcClasses.append(lcCat)
                with arcpy.da.SearchCursor (lcBufferTable, ["FEATID_BUFF",field]) as cursor: # 'lcWetlandsTableFields' = [OID,PES_cat_1, PES_cat_2, ...PES_cat_20] NB will not have all 20, only those with values
                    for row in cursor:
                        if row[0] not in wshedInsideBufferList: #enter only if watershed extends beyond the buffer
                            area = row[1]
##                                area = celCount / 10000
                            if area == 0.0:
                                area = 0
                            if row[0] in lcBuffer:
                                lcBuffer[row[0]].append([lcCat,area])
                            else:
                                lcBuffer[row[0]] = [[lcCat,area]]
                                
                            totalAreaBuffer = bufferAreaDicLC[row[0]]

                            if totalAreaBuffer != 0:
                                lcpercentage = (abs(area)/abs(totalAreaBuffer))*100
                            else:
                                lcpercentage = 0.0
                            if row[0] in lcBuffer_area:
                                lcBuffer_area[row[0]].append([lcCat,lcpercentage])
                            else:
                                lcBuffer_area[row[0]] = [[lcCat,lcpercentage]]
                        else: #Assign value 0 to the buffer if watershed does not extent beyond the buffer, i.e. base PES on watershed alone
                            area = 0
                            if row[0] in lcBuffer:
                                lcBuffer[row[0]].append([lcCat,area]) #Dictionary with lc buffer area values
                            else:
                                lcBuffer[row[0]] = [[lcCat,area]]

                            lcpercentage = 0.0
                            if row[0] in lcBuffer_area:
                                lcBuffer_area[row[0]].append([lcCat,lcpercentage]) #Dictionary with lc buffer percentage area values
                            else:
                                lcBuffer_area[row[0]] = [[lcCat,lcpercentage]]
                arcpy.SetProgressorPosition()
            arcpy.ResetProgressor()
            arcpy.SetProgressorLabel("Calculating PES: Level 1A ...")
##            arcpy.AddMessage ("lcBuffer: " + str(lcBuffer))#$
##            arcpy.AddMessage ("lcBuffer_area: " + str(lcBuffer_area))#$
            
            if len(insideWetlList) > 0: #add values 0 to buffer land cover classes where the watershed in entirely within the wetland
                for lc in lcClasses:
                    for id in insideWetlList:
                        area = 0
                        if id in lcBuffer:
                            lcBuffer[id].append([lc,area]) #Dictionary with lc buffer area values
                        else:
                            lcBuffer[id] = [[lc,area]]
                            
                        lcpercentage = 0.0
                        if id in lcBuffer_area:
                            lcBuffer_area[id].append([lc,lcpercentage]) #Dictionary with lc buffer percentage area values
                        else:
                            lcBuffer_area[id] = [[lc,lcpercentage]]

            arcpy.AddMessage ("      - Calculating percent difference ...")
            featureCount = len(lcWetland) # To manage the progress bar
            arcpy.SetProgressor ("step", "Calculating percent difference ...", 0, featureCount, 1)
##                lcWetland.sort()
            for wetl_ID in lcWetland:
                try:
                    if wetl_ID in bufferAreaDic:
                        valuesList = lcBuffer[wetl_ID]
                        totalLCarea = 0.0
                        for item in valuesList:
                            area = item[1]
                            totalLCarea += area
                            
                        totalAreaBuffer = bufferAreaDic[wetl_ID]

                        percDiff = (100 -((abs(totalLCarea) * 100) / abs(totalAreaBuffer)))
                        if abs(percDiff) > int(errThreshold):
                            arcpy.AddWarning ("       - WARNING: Total buffer land cover area for wetland with '" + wetlandUID + "' " + str(wetl_ID) + " differs from wetland buffer area by " + str(abs(percDiff)) + " percent.")
                            lcBufferList.append(wetl_ID) 
                            lcBufferVar = 1
                        lcBufferListDic[wetl_ID] = abs(percDiff)
                        arcpy.SetProgressorPosition()
                    else:
                        lcBufferListDic[wetl_ID] = 0.0
                    arcpy.SetProgressorPosition()
                except:
                    arcpy.SetProgressorPosition()
                    continue
            arcpy.ResetProgressor()                            
            arcpy.SetProgressorLabel("Calculating PES: Level 1A ...")

            ##Calculate the areas for the watershed land cover classes
            arcpy.AddMessage ("     - For watersheds (including wetland and buffer) ...")
            arcpy.AddMessage ("      - Creating reference list ...")
            PES_catFields = []
            fields = [field.name for field in arcpy.ListFields(lcWshedTable)]
            for field in fields:
                if lcp in field:
                    PES_catFields.append(field) # 'PES_catFields' = list with the landcover field in the area table (not all 20 lc PES categories are listed, only those with values)
            
            arcpy.AddMessage ("      - Calculating watershed land cover class area and percentage ...")
            lcCatchment_incl = {} #Dictionary with lc buffer area values
            featureCount = len(PES_catFields) # To manage the progress bar
            arcpy.SetProgressor ("step", "Calculating watershed land cover class areas ...", 0, featureCount, 1)
            for field in PES_catFields:
                index = field.rfind("_")
                lcCat = field[index+1:]
                with arcpy.da.SearchCursor (lcWshedTable, ["FEATID_ORG",field]) as cursor: # 'lcWetlandsTableFields' = [OID,PES_cat_1, PES_cat_2, ...PES_cat_20] NB will not have all 20, only those with values
                    for row in cursor:
                        area = row[1]
##                            area = celCount / 10000
                        if area == 0.0:
                            area = 0
                        if row[0] in lcCatchment_incl:
                            lcCatchment_incl[row[0]].append([lcCat,area])
                        else:
                            lcCatchment_incl[row[0]] = [[lcCat,area]]
                arcpy.SetProgressorPosition()
            arcpy.ResetProgressor()
            arcpy.SetProgressorLabel("Calculating PES: Level 1A ...")
            
            ##Calculate the areas for the watershed land cover classes
            arcpy.AddMessage ("     - For watersheds (excluding wetland and buffer) ...")
            arcpy.AddMessage ("      - Creating reference list ...")
            PES_catFields = []
            #fields = [field.name for field in arcpy.ListFields(lcWshedTable_excl)]
            fields = [field.name for field in arcpy.ListFields(lcWshedTable)]
            for field in fields:
                if lcp in field:
                    PES_catFields.append(field) # 'PES_catFields' = list with the landcover field in the area table (not all 20 lc PES categories are listed, only those with values)

            arcpy.AddMessage ("      - Calculating watershed land cover class area and percentage ...")
            lcCatchment = {} #Dictionary with lc buffer area values
            lcCatchment_area = {} #Dictionary with lc buffer area values expressed as a percentage of the wetland total area
            featureCount = len(PES_catFields) # To manage the progress bar
            arcpy.SetProgressor ("step", "Calculating watershed land cover class areas ...", 0, featureCount, 1)
            for field in PES_catFields:
                index = field.rfind("_")
                lcCat = field[index+1:]
                #with arcpy.da.SearchCursor (lcWshedTable_excl, ["featID_org",field]) as cursor: # 'lcWetlandsTableFields' = [OID,PES_cat_1, PES_cat_2, ...PES_cat_20] NB will not have all 20, only those with values
                with arcpy.da.SearchCursor (lcWshedTable, ["FEATID_ORG",field]) as cursor: # Excludes wetlands located eintirely within wetland, but includes those entirely within buffer; 'lcWetlandsTableFields' = [OID,PES_cat_1, PES_cat_2, ...PES_cat_20] NB will not have all 20, only those with values
                    for row in cursor:
                        area = row[1]
##                            area = celCount / 10000
                        if area == 0.0:
                            area = 0

                        if area > 0:
                            valueWetl = 0
                            valueBuff = 0
                            
                            keysList = lcWetland.keys()
                            if row[0] in keysList:
                                values = lcWetland[row[0]]
                                for item in values:
                                    if item[0] == lcCat:
                                        valueWetl = item[1]
                                        break

                            keysList = lcBuffer.keys()
                            if row[0] in keysList:
                                values = lcBuffer[row[0]]
                                for item in values:
                                    if item[0] == lcCat:
                                        valueBuff = item[1]
                                        break
                                        
                            value = valueWetl + valueBuff
                            area = area - value
                            area = round(area,4)
                            if abs(area) == 0.0:
                                area = 0

                        if row[0] in lcCatchment:
                            lcCatchment[row[0]].append([lcCat,area])
                        else:
                            lcCatchment[row[0]] = [[lcCat,area]]

                        totalAreaWshed = wshedAreaDicLC[row[0]]

                        areaWetl = 0
                        areaBuff = 0
                        
                        keysList = wetlandAreaDicLC.keys()
                        if row[0] in keysList:
                            areaWetl = wetlandAreaDicLC[row[0]]

                        if row[0] not in wshedInsideBufferList: #Do not subtract lc from buffer for wetlands entirely within buffer, else the watershed will have no lc values
                            keysList = bufferAreaDicLC.keys()
                            if row[0] in keysList:
                                areaBuff = bufferAreaDicLC[row[0]]

                        value = areaWetl + areaBuff
                        totalAreaWshed = totalAreaWshed - value

##                        if row[0] in adjustedNatDic: 
##                            totalAreaWshed = adjustedNatDic[row[0]]
                        if row[0] in wshedAreaDic: 
                            totalAreaWshed = wshedAreaDic[row[0]]
                        
                        if totalAreaWshed != 0:
                            lcpercentage = (abs(area)/abs(totalAreaWshed))*100
                        else:
                            lcpercentage = 0.0
                        if row[0] in lcCatchment_area:
                            lcCatchment_area[row[0]].append([lcCat,lcpercentage])
                        else:
                            lcCatchment_area[row[0]] = [[lcCat,lcpercentage]]
                arcpy.SetProgressorPosition()
            arcpy.ResetProgressor()
##            arcpy.AddMessage ("\n lcCatchment: " + str(lcCatchment))#$ lcCatchment: {87: [[u'1', 393.3169], [u'10', 3699.6117], [u'11', 2078.3723], [u'12', 195.28], 
##            arcpy.AddMessage ("\n lcCatchment_area: " + str(lcCatchment_area))#$ lcCatchment_area: {87: [[u'1', 0.33912732767243836], [u'10', 3.189894533508951], [u'11', 1.792022778597664], [u'12', 0.16837513096404902], 

            if len(insideWetlList) > 0: #get the landcover for watersheds entirely within the wetland
                if arcpy.Exists(lcWshedTable_insideWetl): #i.e. there are watersheds that are entirely within the wetland
                    #for i in lcWetland:
                    for i in insideWetlList:
                        if i in lcCatchment: #Assign the same land cover class in the wetland to the watershed, but all with area = 0
                            del lcCatchment[i]
                            for n in lcList:
                                if i in lcCatchment: #Assign the same land cover class in the wetland to the watershed, but all with area = 0
                                    lcCatchment[i].append([n,0])
                                else:
                                    lcCatchment[i] = [[n,0]]
                        else:
                            for n in lcList:
                                if i in lcCatchment: #Assign the same land cover class in the wetland to the watershed, but all with area = 0
                                    lcCatchment[i].append([n,0])
                                else:
                                    lcCatchment[i] = [[n,0]]

                        if i in lcCatchment_incl: #Assign the same land cover class in the wetland to the watershed, but all with area = 0
                            del lcCatchment_incl[i]
                            for n in lcList:
                                if i in lcCatchment_incl: #Assign the same land cover class in the wetland to the watershed, but all with area = 0
                                    lcCatchment_incl[i].append([n,0])
                                else:
                                    lcCatchment_incl[i] = [[n,0]]
                        else:
                            for n in lcList:
                                if i in lcCatchment_incl: #Assign the same land cover class in the wetland to the watershed, but all with area = 0
                                    lcCatchment_incl[i].append([n,0])
                                else:
                                    lcCatchment_incl[i] = [[n,0]]

                        if i in lcCatchment_area: #Assign the same land cover class in the wetland to the watershed are percentage, but all with percent = 0%
                            del lcCatchment_area[i]
                            for n in lcList:
                                if i in lcCatchment_area: #Assign the same land cover class in the wetland to the watershed, but all with area = 0
                                    lcCatchment_area[i].append([n,0])
                                else:
                                    lcCatchment_area[i] = [[n,0]]
                        else:
                            for n in lcList:
                                if i in lcCatchment_area: #Assign the same land cover class in the wetland to the watershed, but all with area = 0
                                    lcCatchment_area[i].append([n,0])
                                else:
                                    lcCatchment_area[i] = [[n,0]]
##            arcpy.AddMessage ("lcCatchment: " + str(lcCatchment))#$
##            arcpy.AddMessage ("lcCatchment_incl: " + str(lcCatchment_incl))#$
##            arcpy.AddMessage ("lcCatchment_area: " + str(lcCatchment_area))#$

            lcWetland_keys = lcWetland.keys()
            lcBufferd_keys = lcBuffer.keys()
            lcCatchment_keys = lcCatchment.keys()
            lcWetland_area_keys = lcWetland_area.keys()
            lcBuffer_area_keys = lcBuffer_area.keys()
            lcCatchment_area_keys = lcCatchment_area.keys()
            allIDs = list(set.intersection(*map(set, [lcWetland_keys, lcBufferd_keys, lcCatchment_keys, lcWetland_area_keys, lcBuffer_area_keys, lcCatchment_area_keys])))
            for i in allIDs:
                allIDsList.append(i)
            allIDsList.sort() #excludes the OID values of wetlands with watersheds entirely within the buffer of wetland

            arcpy.AddMessage ("      - Calculating percent difference ...")
            featureCount = len(lcWetland) # To manage the progress bar
            arcpy.SetProgressor ("step", "Calculating percent difference ...", 0, featureCount, 1)

##                lcWetland.sort()
            for wetl_ID in lcWetland:
                try:
                    if wetl_ID in wshedAreaDic_excl:                        
                        valuesList = lcCatchment[wetl_ID]
                        totalLCarea = 0.0
                        for item in valuesList:
                            area = item[1]
                            totalLCarea += area

                        totalAreaWshed = wshedAreaDic_excl[wetl_ID]
                        percDiff = (100 -((abs(totalLCarea) * 100) / abs(totalAreaWshed)))
                        if  abs(percDiff) > int(errThreshold):
                            arcpy.AddWarning ("       - WARNING: Total watershed land cover area for wetland with '" + wetlandUID+ "' " + str(wetl_ID) + " differs from wetland watershed area by " + str(abs(percDiff)) + " percent.")
                            lcWatershedList.append(wetl_ID) 
                            lcWatershedVar = 1
                        lcWatershedListDic[wetl_ID] = abs(percDiff)
                        arcpy.SetProgressorPosition()
                    else:
                        if wetl_ID in wshedInsideBufferList:#i.e. the watershed it entirely within the buffer or the wetland
                            if wetl_ID in insideWetlList: #i.e. the watershed it entirely within the wetland
                                #valuesList = lcCatchment[wetl_ID]
                                valuesList = lcCatchment[wetl_ID]
                                totalLCarea = 0.0
                                for item in valuesList:
                                    area = item[1]
                                    totalLCarea += area
                                
                                totalAreaWshed = wshedAreaDicInsideWetl[wetl_ID]
                            else:
                                valuesList = lcCatchment[wetl_ID]
                                totalLCarea = 0.0
                                for item in valuesList:
                                    area = item[1]
                                    totalLCarea += area
                                    
                                totalAreaWshed = wshedAreaDicInsideBuff[wetl_ID]

                            percDiff = (100 -((abs(totalLCarea) * 100) / abs(totalAreaWshed)))
                            if  abs(percDiff) > int(errThreshold):
                                arcpy.AddWarning ("       - WARNING: Total watershed land cover area for wetland with '" + wetlandUID+ "' " + str(wetl_ID) + " differs from wetland watershed area by " + str(abs(percDiff)) + " percent.")
                                lcWatershedList.append(wetl_ID) 
                                lcWatershedVar = 1
                            lcWatershedListDic[wetl_ID] = abs(percDiff)
                                    
                    arcpy.SetProgressorPosition()
                except:
                    lcWatershedListDic[wetl_ID] = 0 # Error caused by division by 0 because watershed is entirely within the wetland
                    arcpy.SetProgressorPosition()
                    continue
##            arcpy.AddMessage ("lcWatershedListDic: " + str(lcWatershedListDic))#$

##            arcpy.AddMessage ("\nlcWetland_area: " + str(lcWetland_area))#$
##            arcpy.AddMessage ("\nlcBuffer_area: " + str(lcBuffer_area))#$
##            arcpy.AddMessage ("\nlcCatchment_area: " + str(lcCatchment_area))#$



            arcpy.AddMessage ("\n>>> Copying result to wetlands feature class ...")
            failedLClist = []
##            arcpy.AddMessage ("lcWetlandList: " + str(lcWetlandList))#$
##            arcpy.AddMessage ("lcBufferList: " + str(lcBufferList))#$
##            arcpy.AddMessage ("lcWatershedList: " + str(lcWatershedList))#$
##                if len(lcWetlandList) > 0 or len(lcBufferList) > 0 or len(lcWatershedList) > 0:
            invalidPESid = list(set(lcWetlandList + lcBufferList + lcWatershedList))
##            arcpy.AddMessage ("invalidPESid: "+ str(invalidPESid))#$
            for x in failedLClist:
                if x not in invalidPESid:
                    invalidPESid.append(x)
##            arcpy.AddMessage ("invalidPESid: "+ str(invalidPESid))#$

            validPESid = [item for item in allWetlList if item not in invalidPESid] 
##            allIDs = validPESid
##            allIDs.append(113)#$
##            arcpy.AddMessage ("allIDs: "+ str(allIDs))#$
##
##            arcpy.AddMessage ("\n allWetlList_n: " + str(allWetlList))#$
##            arcpy.AddMessage ("\n vulnFactDic: " + str(vulnFactDic))#$

            for id in allWetlList:
                if id not in noWatershedList:
##                    if id == 133: arcpy.AddMessage ("\nEnter 113")#$
                    PES_output = [] #Create list to hold the values of 'PES_output'
                    
                    vulnerability_factor = vulnFactDic[id]
                    if id in wshedInsideBufferList:
                        watershedInBuffer = 1 #the watershed does not extend beyond the buffer
                    else:
                         watershedInBuffer = 0 #the watershed extends beyond the buffer
                    HGM_type = HGM_typeDic[id]

                    ##>>> CALCULATE HYDROLOGY <<<
                    #>>> Calculate 'HYDRO_MAR' of sheet 'PES_output'
                    function = "HYDRO_MAR"
                    
                    #Calculate BUFF_mag_
                    BUFF_mag_dic = {} #Create a dictionary to hold the values of 'BUFF_mag_' for each of the land cover classes
                    function = "HYDRO_MAR"
                    zone = lcBuffer_area
                    multiplier = Int_Ext_MAR
                    y = 3
                    BUFF_mag_ (function, zone, multiplier, y, lc_gridcodes, PES_output, vulnerability_factor, watershedInBuffer, id)
                    
                    #Calculate CATCH_mag_
                    CATCH_mag_dic = {} #Create a dictionary to hold the values of 'CATCH_mag_' for each of the land cover classes
                    function = "HYDRO_MAR"
                    zone = lcCatchment_area
                    multiplier = Int_Ext_MAR
                    y = 3
                    CATCH_mag_ (function, zone, multiplier, vulnerability_factor, y, lc_gridcodes, id)
                    
                    #Calculate EXT_MAR
                    zone = lcWetland_area
                    EXT_MAR (zone, lc_gridcodes, HGM_type, HGMdic, PES_output, id)
                   
                    #>>> Calculate 'HYDRO_SEAS' of sheet 'PES_output'
                    function = "HYDRO_SEAS"
                    
                    #Calculate BUFF_mag_Seas
                    BUFF_mag_dic = {} #Create a dictionary to hold the values of 'BUFF_mag_' for each of the land cover classes
                    function = "HYDRO_SEAS"
                    zone = lcBuffer_area
                    multiplier = Int_Ext_Seas
                    y = 2
                    BUFF_mag_ (function, zone, multiplier, y, lc_gridcodes, PES_output, vulnerability_factor, watershedInBuffer, id)
                    
                    #Calculate CATCH_mag_Seas
                    CATCH_mag_dic = {} #Create a dictionary to hold the values of 'CATCH_mag_' for each of the land cover classes
                    function = "HYDRO_SEAS"
                    zone = lcCatchment_area
                    multiplier = Int_Ext_Seas
                    y = 2
                    CATCH_mag_ (function, zone, multiplier, vulnerability_factor, y, lc_gridcodes, id)
                    
                    #Calculate EXT_Seas
                    zone = lcWetland_area
                    EXT_MAR (zone, lc_gridcodes, HGM_type, HGMdic, PES_output, id)

                    #>>> Calculate 'HYDRO_PEA1' of sheet 'PES_output'
                    function = "HYDRO_PEA1"
                    
                    #Calculate BUFF_mag_Peak
                    BUFF_mag_dic = {} #Create a dictionary to hold the values of 'BUFF_mag_' for each of the land cover classes
                    function = "HYDRO_PEA1"
                    zone = lcBuffer_area
                    multiplier = Int_Ext_Peak
                    y = 5
                    BUFF_mag_ (function, zone, multiplier, y, lc_gridcodes, PES_output, vulnerability_factor, watershedInBuffer, id)
                    
                    #Calculate CATCH_mag_Peak
                    CATCH_mag_dic = {} #Create a dictionary to hold the values of 'CATCH_mag_' for each of the land cover classes
                    function = "HYDRO_PEA1"
                    zone = lcCatchment_area
                    multiplier = Int_Ext_Peak
                    y = 5
                    CATCH_mag_ (function, zone, multiplier, vulnerability_factor, y, lc_gridcodes, id)
                    
                    #Calculate EXT_Peak
                    zone = lcWetland_area
                    EXT_MAR (zone, lc_gridcodes, HGM_type, HGMdic, PES_output, id)

                    #>>> Calculate 'HYDRO_PEAK' of sheet 'PES_output'
                    function = "HYDRO_PEAK"

                    HYDRO_PEA1 = PES_output[2]
                    weightPeakValues = weightPeak_dic.get(HGM_type)
                    EXT_Peak_greq_0 = weightPeakValues[0] #Get the HGM type buffer relative weighting
                    EXT_Peak_less_0 = weightPeakValues[1] #Get the HGM type buffer relative weighting

                    if HYDRO_PEA1 < 0:                     
                        hydroPeak = EXT_Peak_less_0 * abs(HYDRO_PEA1)
                    else: 
                        hydroPeak = EXT_Peak_greq_0 * abs(HYDRO_PEA1)

                    PES_output.append(hydroPeak)

                    #>>> Calculate 'HYDRO_EXT' of sheet 'PES_output'
                    function = "HYDRO_EXT"

                    HYDRO_MAR_value = PES_output[0]
                    HYDRO_SEAS_value = PES_output[1]
                    HYDRO_PEAK_value = PES_output[3]
     
                    hydroExt = max(abs(HYDRO_MAR_value), abs(HYDRO_SEAS_value), abs(HYDRO_PEAK_value))

                    PES_output.append(hydroExt)

                    #>>> Calculate HYDRO_WET of sheet 'PES_output'
                    #Calculate WET_mag_Hydro
                    function = "HYDRO_WET"
                    
                    zone = lcWetland_area
                    multiplier = Int_Wet_Hydro
                    WET_mag (function, zone, multiplier, lc_gridcodes, PES_output, id)

                    ##>>> CALCULATE GEOMORPHOLOGY<<<
                    #>>> Calculate 'GEO_SEDEXT' of sheet 'PES_output'
                    #Calculate BUFF_mag_Sed
                    function = "GEO_SEDEXT"
                    
                    BUFF_mag_dic = {} #Create a dictionary to hold the values of 'BUFF_mag_' for each of the land cover classes
                    zone = lcBuffer_area
                    multiplier = Int_Ext_Sed
                    y = 5
                    BUFF_mag_ (function, zone, multiplier, y, lc_gridcodes, PES_output, vulnerability_factor, watershedInBuffer, id)
                    
                    #Calculate CATCH_mag_Sed
                    function = "GEO_SEDEXT"
                    zone = lcCatchment_area
                    multiplier = Int_Ext_Sed
                    y = 5
                    CATCH_mag_ (function, zone, multiplier, vulnerability_factor, y, lc_gridcodes, id)
                    
                    #Calculate EXT_Sed
                    zone = lcWetland_area
                    EXT_MAR (zone, lc_gridcodes, HGM_type, HGMdic, PES_output, id)

                    #>>> Calculate 'GEO_SEDWET' of sheet 'PES_output'
                    #Calculate 'WET_mag_Geo_Pr'
                    function = "GEO_SEDWET"

                    zone = lcWetland_area
                    multiplier = Int_Wet_Geo_Pr 
                    WET_mag (function, zone, multiplier, lc_gridcodes, PES_output, id)

                    #Calculate 'GEO_PROC' of sheet 'PES_output'
                    function = "GEO_PROC"
                    
                    GEO_SEDEXT = PES_output[6]
                    GEO_SEDWET = PES_output[7]
                    GEO_PROC = abs(GEO_SEDEXT) + ((10-abs(GEO_SEDEXT)) * GEO_SEDWET/10)

                    PES_output.append(GEO_PROC)

                    #>>> Calculate 'GEO_STRUCT' of sheet 'PES_output'
                    #Calculate 'WET_mag_Geo_Sr'
                    function = "GEO_STRUCT"
                    
                    zone = lcWetland_area
                    multiplier = Int_Wet_Geo_St 
                    WET_mag (function, zone, multiplier, lc_gridcodes, PES_output, id)

                    ##>>> CALCULATE WATER QUALITY<<<
                    #>>> Calculate WQ_EXT of sheet 'PES_output'
                    #Calculate BUFF_mag_WQ
                    function = "WQ_EXT"

                    BUFF_mag_dic = {} #Create a dictionary to hold the values of 'BUFF_mag_' for each of the land cover classes
                    zone = lcBuffer_area
                    multiplier = Int_Ext_WQ
                    y = 3 
                    BUFF_mag_ (function, zone, multiplier, y, lc_gridcodes, PES_output, vulnerability_factor, watershedInBuffer, id)

                    #Calculate CATCH_mag_WQ
                    function = "WQ_EXT"
                    
                    zone = lcCatchment_area
                    multiplier = Int_Ext_WQ
                    vulnerability_factor = 0
                    y = 2
                    CATCH_mag_ (function, zone, multiplier, vulnerability_factor, y, lc_gridcodes, id)

                    #Calculate EXT_WQ
                    zone = lcWetland_area
                    EXT_MAR (zone, lc_gridcodes, HGM_type, HGMdic, PES_output, id)

                    #>>> CALCULATE 'WQ_WET' of sheet 'PES_output'
                    #Calculate WET_mag_WQ
                    function = "WQ_WET"

                    BUFF_mag_dic = {} #Create a dictionary to hold the values of 'BUFF_mag_' for each of the land cover classes
                    zone = lcWetland_area
                    multiplier = Int_Wet_WQ
                    y = 5 
                    BUFF_mag_ (function, zone, multiplier, y, lc_gridcodes, PES_output, vulnerability_factor, watershedInBuffer, id)

                    ##>>> CALCULATE VEGETATION<<<
                    #>>> CALCULATE 'VEG_mag_Veg' of sheet 'PES_output'
                    #Calculate WET_mag_Veg
                    function = "VEG_WET"

                    zone = lcWetland_area
                    multiplier = Int_Wet_Veg
                    WET_mag (function, zone, multiplier, lc_gridcodes, PES_output, id)                    

                    ##CALCULATE PES_SUMMARY
                    PES_summary = [] #Create list to hold to the results to be written to the feature class

                    HYDRO_MAR = PES_output[0] #PES_output!D7
                    HYDRO_SEAS = PES_output[1] #PES_output!E7
                    HYDRO_PEA1 = PES_output[2] #PES_output!F7
                    HYDRO_PEAK = PES_output[3] #PES_output!G7
                    HYDRO_EXT = PES_output[4] #PES_output!H7 *
                    HYDRO_WET = PES_output[5] #PES_output!I7 *
                    GEO_SEDEXT = PES_output[6] #PES_output!J7
                    GEO_SEDWET = PES_output[7] #PES_output!K7
                    GEO_PROC = PES_output[8] #PES_output!L7 *
                    GEO_STRUCT = PES_output[9] #PES_output!M7 *
                    WQ_EXT = PES_output[10] #PES_output!N7 *
                    WQ_WET = PES_output[11] #PES_output!O7 *
                    VEG_WET = PES_output[12] #PES_output!P7

                    #CALCULATE HYDROLOGY
                    #Calculate 'Impact Score': IMPACT_HYD
                    EC_HYDRO = "" #To account for incidences of EC_HYDRO == "" when calculating the 'Confidence'
                    IMPACT_HYD = HYDRO_EXT + (10 - HYDRO_EXT) * (HYDRO_WET/10)
                    
                    PES_summary.append(IMPACT_HYD)#Calculate 'PES Score (%)': PES_HYDRO
                    PES_HYDRO = ((10-IMPACT_HYD)/10 * 100)
                    
                    PES_summary.append(PES_HYDRO)

                    #Calculate 'Ecological Category': EC_HYDRO
                    if IMPACT_HYD < 1:
                        EC_HYDRO = "A"
                    if IMPACT_HYD >= 1 and IMPACT_HYD < 2:
                        EC_HYDRO = "B"
                    if IMPACT_HYD >= 2 and IMPACT_HYD < 4:
                        EC_HYDRO = "C"
                    if IMPACT_HYD >= 4 and IMPACT_HYD < 6:
                        EC_HYDRO = "D"
                    if IMPACT_HYD >= 6 and IMPACT_HYD < 8:
                        EC_HYDRO = "E"
                    if IMPACT_HYD >= 8:
                        EC_HYDRO = "F"

                    PES_summary.append(EC_HYDRO)

                    #CALCULATE GEOMORHOLOGY
                    #Calculate 'Impact Score': IMPACT_GEO
                    IMPACT_GEO = (GEO_PROC + GEO_STRUCT) / 2
                    PES_summary.append(IMPACT_GEO)

                    #Calculate 'PES Score (%)': PES_GEO
                    PES_GEO = ((10-IMPACT_GEO)/10 * 100)
                    PES_summary.append(PES_GEO)

                    #Calculate 'Ecological Category': EC_GEO
                    if IMPACT_GEO < 1:
                        EC_GEO = "A"
                    if IMPACT_GEO >= 1 and IMPACT_GEO < 2:
                        EC_GEO = "B"
                    if IMPACT_GEO >= 2 and IMPACT_GEO < 4:
                        EC_GEO = "C"
                    if IMPACT_GEO >= 4 and IMPACT_GEO < 6:
                        EC_GEO = "D"
                    if IMPACT_GEO >= 6 and IMPACT_GEO < 8:
                        EC_GEO = "E"
                    if IMPACT_GEO >= 8:
                        EC_GEO = "F"

                    PES_summary.append(EC_GEO)

                    #CALCULATE WATER QUALITY
                    #Calculate 'Impact Score': IMPACT_WQ
                    IMPACT_WQ = max(WQ_EXT, WQ_WET)

                    PES_summary.append(IMPACT_WQ)

                    #Calculate 'PES Score (%)': PES_WQ
                    PES_WQ = ((10-IMPACT_WQ)/10 * 100)
                    
                    PES_summary.append(PES_WQ)
                    
                    #Calculate 'Ecological Category': EC_WQ
                    if IMPACT_WQ < 1:
                        EC_WQ = "A"
                    if IMPACT_WQ >= 1 and IMPACT_WQ < 2:
                        EC_WQ = "B"
                    if IMPACT_WQ >= 2 and IMPACT_WQ < 4:
                        EC_WQ = "C"
                    if IMPACT_WQ >= 4 and IMPACT_WQ < 6:
                        EC_WQ = "D"
                    if IMPACT_WQ >= 6 and IMPACT_WQ < 8:
                        EC_WQ = "E"
                    if IMPACT_WQ >= 8:
                        EC_WQ = "F"

                    PES_summary.append(EC_WQ)

                    #CALCULATE VEGETATION
                    #Calculate 'Impact Score': IMPACT_VEG
                    IMPACT_VEG = VEG_WET

                    PES_summary.append(IMPACT_VEG)

                    #Calculate 'PES Score (%)': PES_VEG
                    PES_VEG = ((10-IMPACT_VEG)/10)*100
                    
                    PES_summary.append(PES_VEG)
                    
                    #Calculate 'Ecological Category': EC_VEG
                    if IMPACT_VEG < 1:
                        EC_VEG = "A"
                    if IMPACT_VEG >= 1 and IMPACT_VEG < 2:
                        EC_VEG = "B"
                    if IMPACT_VEG >= 2 and IMPACT_VEG < 4:
                        EC_VEG = "C"
                    if IMPACT_VEG >= 4 and IMPACT_VEG < 6:
                        EC_VEG = "D"
                    if IMPACT_VEG >= 6 and IMPACT_VEG < 8:
                        EC_VEG = "E"
                    if IMPACT_VEG >= 8:
                        EC_VEG = "F"

                    PES_summary.append(EC_VEG)

                    #CALCULATE OVERALL CONDITION
                    #Calculate 'Combined Impact Score': IMPACT_ALL
                    IMPACT_ALL_value = 0.0 #To account for incidences of IMPACT_ALL_value == "" when calculating the 'Hectare equivalent'
                    if EC_HYDRO == "E" or EC_HYDRO == "F":
                        IMPACT_ALL_value = ((IMPACT_HYD * 6) + (IMPACT_GEO * 2) + (IMPACT_WQ * 2) + (IMPACT_VEG * 2)) / 12
                    else:
                        IMPACT_ALL_value = ((IMPACT_HYD * 3) + (IMPACT_GEO * 2) + (IMPACT_WQ * 2) + (IMPACT_VEG * 2)) / 9

                    PES_summary.append(IMPACT_ALL_value)

                    #Calculate 'Overall PES Score (%)': PES_ALL
                    PES_ALL = ((10 - IMPACT_ALL_value) / 10) * 100

                    PES_summary.append(PES_ALL)

                    #Calculate 'Combined Ecological Category': EC_ALL           
                    if IMPACT_ALL_value < 1:
                        EC_ALL = "A"
                    if IMPACT_ALL_value >= 1 and IMPACT_ALL_value < 2:
                        EC_ALL = "B"
                    if IMPACT_ALL_value >= 2 and IMPACT_ALL_value < 4:
                        EC_ALL = "C"
                    if IMPACT_ALL_value >= 4 and IMPACT_ALL_value < 6:
                        EC_ALL = "D"
                    if IMPACT_ALL_value >= 6 and IMPACT_ALL_value < 8:
                        EC_ALL = "E"
                    if IMPACT_ALL_value >= 8:
                        EC_ALL = "F"

                    PES_summary.append(EC_ALL)

                    #Calculate 'Split Ecological Category': SEC_ALL           
                    if IMPACT_ALL_value <= 0.9:
                        SEC_ALL = "A"
                    if IMPACT_ALL_value > 0.9 and IMPACT_ALL_value < 1.1:
                        SEC_ALL = "A/B"
                    if IMPACT_ALL_value >= 1.1 and IMPACT_ALL_value <= 1.9:
                        SEC_ALL = "B"
                    if IMPACT_ALL_value > 1.9 and IMPACT_ALL_value < 2.2:
                        SEC_ALL = "B/C"
                    if IMPACT_ALL_value >= 2.2 and IMPACT_ALL_value <= 3.8:
                        SEC_ALL = "C"
                    if IMPACT_ALL_value > 3.8 and IMPACT_ALL_value < 4.2:
                        SEC_ALL = "C/D"
                    if IMPACT_ALL_value >= 4.2 and IMPACT_ALL_value <= 5.8:
                        SEC_ALL = "D"
                    if IMPACT_ALL_value > 5.8 and IMPACT_ALL_value < 6.2:
                        SEC_ALL = "D/E"
                    if IMPACT_ALL_value >= 6.2 and IMPACT_ALL_value <= 7.8:
                        SEC_ALL = "E"
                    if IMPACT_ALL_value > 7.8 and IMPACT_ALL_value < 8.2:
                        SEC_ALL = "E/F"
                    if IMPACT_ALL_value >= 8.2:
                        SEC_ALL = "F"

                    PES_summary.append(SEC_ALL)

                    #CALCULATE THE HECTARE EQUIVALENTS (based on Overall PES): HA_EQUIV
                    if IMPACT_ALL_value == 0:
                        HA_EQUIV = None
                    else:
                        HA_EQUIV = (PES_ALL / 100) * wetlandAreaDic[id] #To calculate hectar equivalent of the wetland area determined from total of intersecting land cover classes totalAreaWetland = wetlandAreaDic[row[0]]

                    PES_summary.append(HA_EQUIV)

                    #CALCULATE CONFIDENCE
                    if EC_HYDRO == "":
                        Confidence = ""
                    else:
                        if IMPACT_WQ == "E" or IMPACT_WQ == "F":
                            Confidence = ((PES_GEO * 6) + (PES_WQ * 2) + (PES_VEG * 2) + (PES_ALL * 2)) / 12
                        else:
                            Confidence = ((PES_GEO * 3) + (PES_WQ * 2) + (PES_VEG * 2) + (PES_ALL * 2)) / 9

                    ConfidenceResult = ""
                    wetSet = wetSetDic[id]
                    if wetSet == "Coastal plain" or wetSet == "Karst landscape":
                        ConfidenceResult = "(" + str(Confidence) + "); Very low confidence: evaluation of groundwater connectivity and quality required"
                    else:
                        ConfidenceResult = "(" + str(Confidence) + "); Low confidence: Level 1A landcover-based desktop assessment"

                    PES_summary.append(ConfidenceResult)

                    PES_summary.append(wshedComplWithinVar)

                    PES_summary.append(lcWetlandVar)
                    
                    PES_summary.append(lcBufferVar)
                    
                    PES_summary.append(lcWatershedVar)
                    
                    PES_summary.append(lcBufferWatershedVar)
                    
                    PES_summary_dic[id] = PES_summary
##                    if id == 133: arcpy.AddMessage ("\nExit 113")#$
                else:
                    arcpy.AddWarning ("     - Skipping wetland with no watershed; 'featOID' value: " + str(id) + " ...")

            ##WRITE THE RESULTS TO THE FEATURE CLASS

            if pesDone_one == 0: #Enter only if all records had value 0 in field 'pesDONE'
                if (len(arcpy.ListFields(wetlands, "Setting")) != 0): 
                    arcpy.DeleteField_management(wetlands, ["Setting",])
                arcpy.AddField_management (wetlands, "Setting", "TEXT", "", "", 50)
##            else:
##                arcpy.AddField_management (wetlands, "Setting", "TEXT", "", "", 50)

            #                           0               1           2           3           4           5       6           7           8           9           10      11          12          13          14          15          16          17              18              19                  20                  21              22              23          24          25
            PES_fields_wetlands = ["IMPACT_HYD", "PES_HYDRO", "EC_HYDRO", "IMPACT_GEO", "PES_GEO", "EC_GEO", "IMPACT_WQ", "PES_WQ", "EC_WQ", "IMPACT_VEG", "PES_VEG", "EC_VEG", "IMPACT_ALL", "PES_ALL", "EC_ALL", "SEC_ALL", "HA_EQUIV", "Confidence", "wshedInBuffer", "wetlandLandcover", "bufferLandcover", "wshedLandcover", "wshedInWetland", "pesDONE", wetlandUID, "Setting"]

##            arcpy.AddMessage ("PES_summary_dic: " + str(PES_summary_dic))#$
            a = 9 #$
##            arcpy.CopyFeatures_management(wetlands,r'C:\NWM\scratch.gdb\wetlandsA')#$
##            pesDONEresults_Dic = {} #Dictionary to hold the results if there were reords with value 0 in field 'pesDONE', in which case the results at the moment are in a temporary wetland feature class
            with arcpy.da.UpdateCursor (wetlands, PES_fields_wetlands) as cursor:
                for row in cursor:
                    if row[24] in PES_summary_dic:
##                        arcpy.AddMessage ("PES for: " + str(row[24]))#$
                        resultsList = []
                        PES_summary = PES_summary_dic[row[24]]
                        if a == 9:#$
                            row[0] = PES_summary[0]
                            row[1] = PES_summary[1]
                            row[2] = PES_summary[2]
                            row[3] = PES_summary[3]
                            row[4] = PES_summary[4]
                            row[5] = PES_summary[5]
                            row[6] = PES_summary[6]
                            row[7] = PES_summary[7]
                            row[8] = PES_summary[8]
                            row[9] = PES_summary[9]
                            row[10] = PES_summary[10]
                            row[11] = PES_summary[11]
                            row[12] = PES_summary[12]
                            row[13] = PES_summary[13]
                            row[14] = PES_summary[14]
                            row[15] = PES_summary[15]
                            row[16] = PES_summary[16]
                            row[17] = PES_summary[17]
                            row[18] = PES_summary[18]
                            row[19] = PES_summary[19]
                            row[20] = PES_summary[20]
                            row[21] = PES_summary[21]
                            row[22] = PES_summary[22]
                            row[25] = wetSetDic[row[24]]

                            row[23] = 1

                        else:#$
                            row[0] = round(PES_summary[0],1)
                            row[1] = round(PES_summary[1],1)
                            row[2] = PES_summary[2]
                            row[3] = round(PES_summary[3],1)
                            row[4] = round(PES_summary[4],1)
                            row[5] = PES_summary[5]
                            row[6] = round(PES_summary[6],1)
                            row[7] = round(PES_summary[7],1)
                            row[8] = PES_summary[8]
                            row[9] = round(PES_summary[9],1)
                            row[10] = round(PES_summary[10],1)
                            row[11] = PES_summary[11]
                            row[12] = round(PES_summary[12],1)
                            row[13] = round(PES_summary[13],1)
                            row[14] = PES_summary[14]
                            row[15] = PES_summary[15]
                            row[16] = round(PES_summary[16],1)
                            row[17] = PES_summary[17]
                            row[18] = PES_summary[18]
                            row[19] = PES_summary[19]
                            row[20] = PES_summary[20]
                            row[21] = PES_summary[21]
                            row[22] = PES_summary[22]
                            row[25] = wetSetDic[row[24]]
                            
                            row[23] = 1

                        if a == 9:
                            resultsList.append(str(PES_summary[0]))
                            resultsList.append(str(PES_summary[1]))
                            resultsList.append(str(PES_summary[2]))
                            resultsList.append(str(PES_summary[3]))
                            resultsList.append(str(PES_summary[4]))
                            resultsList.append(str(PES_summary[5]))
                            resultsList.append(str(PES_summary[6]))
                            resultsList.append(str(PES_summary[7]))
                            resultsList.append(str(PES_summary[8]))
                            resultsList.append(str(PES_summary[9]))
                            resultsList.append(str(PES_summary[10]))
                            resultsList.append(str(PES_summary[11]))
                            resultsList.append(str(PES_summary[12]))
                            resultsList.append(str(PES_summary[13]))
                            resultsList.append(str(PES_summary[14]))
                            resultsList.append(str(PES_summary[15]))
                            resultsList.append(str(PES_summary[16]))
                            resultsList.append(str(PES_summary[17]))
                            resultsList.append(str(PES_summary[18]))
                            resultsList.append(str(PES_summary[19]))
                            resultsList.append(str(PES_summary[20]))
                            resultsList.append(str(PES_summary[21]))
                            resultsList.append(str(PES_summary[22]))
                            row[25] = wetSetDic[row[24]]

                            resultsList.append(str(1))

                        else:
                            resultsList.append(round(str(PES_summary[0]),1))
                            resultsList.append(round(str(PES_summary[1]),1))
                            resultsList.append(PES_summary[2])
                            resultsList.append(round(str(PES_summary[3]),1))
                            resultsList.append(round(str(PES_summary[4]),1))
                            resultsList.append(str(PES_summary[5]))
                            resultsList.append(round(str(PES_summary[6]),1))
                            resultsList.append(round(str(PES_summary[7]),1))
                            resultsList.append(str(PES_summary[8]))
                            resultsList.append(round(str(PES_summary[9]),1))
                            resultsList.append(round(str(PES_summary[10]),1))
                            resultsList.append(str(PES_summary[11]))
                            resultsList.append(round(str(PES_summary[12]),1))
                            resultsList.append(round(str(PES_summary[13]),1))
                            resultsList.append(str(PES_summary[14]))
                            resultsList.append(str(PES_summary[15]))
                            resultsList.append(round(str(PES_summary[16]),1))
                            resultsList.append(str(PES_summary[17]))
                            resultsList.append(str(PES_summary[18]))
                            resultsList.append(str(PES_summary[19]))
                            resultsList.append(str(PES_summary[20]))
                            resultsList.append(str(PES_summary[21]))
                            resultsList.append(str(PES_summary[22]))
                            row[25] = wetSetDic[row[24]]
                            
                            resultsList.append(str(1))
                        
                        cursor.updateRow(row)
                        resultsPrintDic[row[24]] = resultsList #Write the results to the dictionary

            #Copy the results from the records with value 0 in field 'pesDONE' to the wetlands feature class
            if pesDone_one == 1: #Enter only if there were records with value 1 and 0 in field 'pesDONE', i.e. if PES not calculated for all wetlands
##                arcpy.AddMessage ("\n wetlands_org: " + str(wetlands_org))#$
##                arcpy.AddMessage ("\n resultsPrintDic: " + str(resultsPrintDic))#$
##                arcpy.CopyFeatures_management(wetlands,r'C:\NWM\scratch.gdb\data\wetlands')#$
##                arcpy.CopyFeatures_management(wetlands_org,r'C:\NWM\scratch.gdb\data\wetlands_org')#$
                wetlands = wetlands_org
##                fields = [field.name for field in arcpy.ListFields(wetlands)] #$
##                arcpy.AddMessage ("fields: " + str(fields))#$

                with arcpy.da.UpdateCursor (wetlands, PES_fields_wetlands) as cursor:
                    for row in cursor:
                        if row[24] in resultsPrintDic:
                            values = resultsPrintDic[row[24]]
##                            arcpy.AddMessage ("\n values: " + str(values))#$
                            row[0] = values[0]
                            row[1] = values[1]
                            row[2] = values[2]
                            row[3] = values[3]
                            row[4] = values[4]
                            row[5] = values[5]
                            row[6] = values[6]
                            row[7] = values[7]
                            row[8] = values[8]
                            row[9] = values[9]
                            row[10] = values[10]
                            row[11] = values[11]
                            row[12] = values[12]
                            row[13] = values[13]
                            row[14] = values[14]
                            row[15] = values[15]
                            row[16] = values[16]
                            row[17] = values[17]
                            row[18] = values[18]
                            row[19] = values[19]
                            row[20] = values[20]
                            row[21] = values[21]
                            row[22] = values[22]
                            row[23] = 1
                            row[25] = wetSetDic[row[24]]
                            cursor.updateRow(row)

            #Create the dictionaries and lists to copy the data to the parameter text file
            wetlandIDList.sort()
            lcWetland_keys.sort()

            #Wetland land cover area (ha)
            for id in wetlandIDList:#loop through the wetland ID values (contains IDs of all wetlands, inclusing those with wshed limited to buffer and wetland)
                lcWetlandAreaDic = {}
                txtWetlandAreaList = []
                if id in lcWetland: # e.g. lcWetland: {179: [[u'2', 0], [u'3', 4.7575], [u'8', 1.115],
                    values = lcWetland[id]
                    for item in values:
                        lcWetlandAreaDic[int(item[0])] = item[1]

                    for n in lcList:
                        if n in lcWetlandAreaDic:
                            txtWetlandAreaList.append(str(lcWetlandAreaDic[n]))
                        else: 
                            txtWetlandAreaList.append("0")
                txtWetlandAreaListFin[id] = txtWetlandAreaList

            #Buffer land cover area (ha)
            for id in wetlandIDList:#loop through the wetland ID values (contains IDs of all wetlands, inclusing those with wshed limited to buffer and wetland)
                lcBufferAreaDic = {}
                txtBufferAreaList = []
                if id in lcBuffer: # e.g. lcWetland: {179: [[u'2', 0], [u'3', 4.7575], [u'8', 1.115],
                    values = lcBuffer[id]
                    for item in values:
                        lcBufferAreaDic[int(item[0])] = item[1]

                    for n in lcList:
                        if n in lcBufferAreaDic: #e.g. lcBufferAreaDic: {2: 0, 3: 4.7575, 4: 0.3825, 8: 1.115,
                            txtBufferAreaList.append(str(lcBufferAreaDic[n]))
                        else: 
                            txtBufferAreaList.append("0")
                txtBufferAreaListFin[id] = txtBufferAreaList # e.g. txtBufferAreaListFin: {179: ['0', '0', '4.7575', '0.3825', '0', '0', '0'

            #Watershed land cover area (ha) (including wetland and watershed)
            for id in wetlandIDList:#loop through the wetland ID values (contains IDs of all wetlands, inclusing those with wshed limited to buffer and wetland)
                lcWshedAreaDic = {}
                txtWshedAreaList = []
                if id in lcCatchment_incl:
                    values = lcCatchment_incl[id]
                    for item in values:
                        lcWshedAreaDic[int(item[0])] = item[1]

                    for n in lcList:
                        if n in lcWshedAreaDic:
                            txtWshedAreaList.append(str(lcWshedAreaDic[n]))
                        else: 
                            txtWshedAreaList.append("0")
                txtWatershedAreaListFin_incl[id] = txtWshedAreaList

            #Watershed land cover area (ha) (excluding wetland and watershed)
            for id in wetlandIDList:#loop through the wetland ID values (contains IDs of all wetlands, inclusing those with wshed limited to buffer and wetland)
                lcWshedAreaDic = {}
                txtWshedAreaList = []
                if id in lcCatchment:
                    values = lcCatchment[id]
                    for item in values:
                        lcWshedAreaDic[int(item[0])] = item[1]

                    for n in lcList:
                        if n in lcWshedAreaDic:
                            txtWshedAreaList.append(str(lcWshedAreaDic[n]))
                        else: 
                            txtWshedAreaList.append("0")
                txtWatershedAreaListFin_excl[id] = txtWshedAreaList

        ## START
        arcpy.AddMessage ("\n>>> This GIS tool was developed based on Level 1 of the updated WET-Health tools:")
        arcpy.AddMessage ("    > Macfarlane, D.M., Ollis, D.J. and Kotze, D.C., 2020. WET-Health (Version 2): A refined suite of tools for assessing the Present Ecological State of wetland ecosystems. Technical Guide. WRC Report No. TT 820/20. May 2020.")

        arcpy.AddMessage ("\n>>> Version: 2.22")
        arcpy.Delete_management ("in_memory")

        #Ensure that the input parameter have a path
        if wetlands != None:
            if ":" not in wetlands:
                desc = arcpy.Describe(wetlands)
                path = desc.path
                wetlands = path + "\\" + wetlands
                wetlands_org = wetlands
            else:
                wetlands_org = wetlands
##        arcpy.AddMessage ("\nwetlands_org: " + str(wetlands_org))#$
        
        if watersheds != None:
            if ":" not in watersheds:
                desc = arcpy.Describe(watersheds)
                path = desc.path
                watersheds = path + "\\" + watersheds

        if landcover != None:
            if ":" not in landcover:
                desc = arcpy.Describe(landcover)
                path = desc.path
                landcover = path + "\\" + landcover
        arcpy.env.snapRaster = landcover

        if quatCatchment != None:
            if ":" not in quatCatchment:
                desc = arcpy.Describe(quatCatchment)
                path = desc.path
                quatCatchment = path + "\\" + quatCatchment

        #Check and delete the topology if it exists
        if arcpy.Exists(wetlands + "_topol"):
            arcpy.Delete_management(wetlands + "_topol")

        #First check if you are in an editing session (true if AddField fails)
        arcpy.AddMessage ("\n>>> Validating arguments ..." )

        #Clear any wetland selections
        if wetlands not in ["", " ", None]:
            try:
                arcpy.SelectLayerByAttribute_management(wetlands,"CLEAR_SELECTION")
            except:
                pass

        #Clear any watershed selections
        if watersheds not in ["", " ", None]:
            try:
                arcpy.SelectLayerByAttribute_management(watersheds,"CLEAR_SELECTION")
            except:
                pass

        #Clear any Quaternary catchments selections
        if quatCatchment not in ["", " ", None]:
            try:
                arcpy.SelectLayerByAttribute_management(quatCatchment,"CLEAR_SELECTION")
            except:
                pass

##        with arcpy.da.UpdateCursor (wetlands_org, ["OID@","pesDONE"]) as cursor: #$
##            for row in cursor: #$
##                if row[0] <= 10:#$
##                    row[1] = 0 #$
##                else:
##                    row[1] = 1 #$
##                cursor.updateRow(row) #$

        #Ensure that the 'Project fetaure class' projection is the same as that of the DEM
        spatialWetlands = arcpy.Describe(wetlands).SpatialReference
        spatialHydroterr = arcpy.Describe(wetlandSetting).SpatialReference
        spatialWatersheds = arcpy.Describe(watersheds).SpatialReference
        spatialLandcover = arcpy.Describe(landcover).SpatialReference
        spatialQuarternary = arcpy.Describe(quatCatchment).SpatialReference
        
        if spatialWetlands.Name != spatialHydroterr.Name != spatialWatersheds.Name != spatialLandcover.Name != spatialQuarternary.Name:
            arcpy.AddError ("\nERROR: The input feature classes are not all of similar projection.\n")
            exit()

        #Create the scratch workspaces and folders
##        clear_scratchGrids = []
        projectPath = os.path.dirname(os.path.abspath(__file__))
        if blnInMemory.lower() == 'false': #Scratch data are copied to the scratch geodatabase

            scratchWorkspace = os.path.join (projectPath, "scratch.gdb")
##            scratchGrids = os.path.join (projectPath, "scratch.gdb")
            try:
                if not arcpy.Exists(scratchWorkspace):
                    arcpy.AddMessage ("\n>>> Creating the scratch workspace ...")
                    arcpy.CreateFileGDB_management  (projectPath, "scratch.gdb", "CURRENT") #Create the scratch workspace
                else:
                    #clearScratch() #Clear the scratch worspace
                    arcpy.CreateFileGDB_management  (projectPath, "scratch.gdb", "CURRENT") #Create the scratch workspace
            except:
                arcpy.AddError ("\nERROR: An unexpected error occurred creating the scratch workspace.")
                arcpy.AddError ("   - Suspect existing Geodatabase or folder with name '" + projectPath + "\\scratch.gdb' in '" + str(projectPath) + "' or in its subfolders.")
                arcpy.AddError ("   - Close ArcGIS, delete if found and rerun.\n")
                exit()

            if not arcpy.Exists(scratchWorkspace):
                arcpy.AddError ("\n     ERROR: Failed to create scratch workspace '" + scratchWorkspace + "'. Create manually and re-run the tool.")
                exit()                
        else:
            scratchWorkspace = "in_memory"

##            scratchGrids = os.path.join (projectPath, "scratch.gdb")
##            if correctErrors.lower() == "true": #i.e. have to create copies of the land cover grids
##                try:
##                    if not arcpy.Exists(scratchGrids):
##                        arcpy.AddMessage ("\n>>> Creating the grid scratch workspace ...")
##                        arcpy.CreateFileGDB_management  (projectPath, "scratch.gdb", "CURRENT") #Create the scratch workspace
##                    else:
##                        #clearScratch() #Clear the scratch worspace
##                        arcpy.CreateFileGDB_management  (projectPath, "scratch.gdb", "CURRENT") #Create the scratch workspace
##                except:
##                    arcpy.AddError ("\nERROR: An unexpected error occurred creating the scratch workspace.")
##                    arcpy.AddError ("   - Suspect existing Geodatabase or folder with name '" + projectPath + "\\scratch.gdb' in '" + str(projectPath) + "' or in its subfolders.")
##                    arcpy.AddError ("   - Close ArcGIS, delete if found and rerun, else create manually.\n")
##                    exit()
##
##                if not arcpy.Exists(scratchGrids):
##                    arcpy.AddError ("\n     ERROR: Failed to create scratch workspace '" + scratchGrids + "'. Create manually and re-run the tool.\n")
##                    exit()

        parameters = []
        now = datetime.datetime.now()
        parameters.append("Date and Time: " + now.strftime("%Y-%m-%d %H:%M"))
        parameters.append("Use the 'in_memory' workspace: " + str(blnInMemory))
        parameters.append("Input: Wetland features: " + str(wetlands))
        parameters.append("Field with wetland feature unique identifier: " + str(wetlandUID))
        parameters.append("Ouput location (folder) for parameter text file: " + str(parameterFolder))
        parameters.append("Field with wetland landscape setting: " + str(wetlandSetting))
        parameters.append("Wetland type: " + str(wetlandType))
        parameters.append("Field with level 4A HGM classification: " + str(field_HGM)) 
        parameters.append("Default HGM type: " + str(hgmDefault))
        parameters.append("Input: Watersheds: " + str(watersheds))
        parameters.append("Distance upsteam of wetland to include in analysis: " + str(upstreamDistance))
        parameters.append("Watershed field with wetland identifier: " + str(field_watersheds))
        parameters.append("Input: Land cover: " + str(landcover))
        parameters.append("Field with broad land cover category: " + str(lcField))
        parameters.append("Input: Quaternary catchments: " + str(quatCatchment))
        parameters.append("Field with quaternary catchment Mean Annual Precipitation (MAP; mm): " + str(MAPfield))
        parameters.append("Field with quaternary catchment Mean Annual Evaporation (MAE; mm): " + str(MAEfield))
        parameters.append("Total land cover area and feature area difference threshold: " + str(errThreshold))

        arcpy.Delete_management ("in_memory")
        
        #Enable overwriting files
        arcpy.env.overwriteOutput = True       

        # Script parameters
        arcpy.AddMessage ("\n>>> Validating tool parameters and wetlands feature class data ...")

##        arcpy.AddMessage ("     - Validating the land cover grid ...")
##        lcList = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
##        lcListErr = []
##        with arcpy.da.SearchCursor (landcover, [lcField,]) as cursor:
##            for row in cursor:
##                if row[0] not in lcList:
##                    if row[0] not in lcListErr:
##                        lcListErr.append(row[0])
##        if len(lcListErr) > 0:
##            errTxt =  ", ".join(str(x) for x in lcListErr)
##            arcpy.AddWarning ("      - FAILED: Invalid broad land cover classes are: " + str(errTxt) + ". Must be between or including values 1 to 19.")
##            arcpy.AddMessage ("\n")
##            exit()
##        else:
##            arcpy.AddMessage ("      - PASS")

        arcpy.AddMessage ("     - Validating feature geometry ...")
        geometryTable = "in_memory\\geometryTable"
        
        feature = wetlands
        arcpy.CheckGeometry_management ([feature, ], geometryTable)
        geomCounter = int(arcpy.GetCount_management(geometryTable).getOutput(0))
        geomCheck = 0
        while int(arcpy.GetCount_management(geometryTable).getOutput(0)) > 0 and geomCounter != geomCheck:
            geomCheck = geomCounter
            arcpy.RepairGeometry_management (feature, "DELETE_NULL")
            arcpy.CheckGeometry_management ([feature, ], geometryTable)
            geomCounter = int(arcpy.GetCount_management(geometryTable).getOutput(0))
        
        #Get the projection from 'wetlands'
        sr = arcpy.CreateSpatialReference_management("", wetlands)

        #Get the field name of the unique identifiers
        watershedUID = arcpy.Describe(watersheds).oidFieldName
        settingUID = arcpy.Describe(wetlandSetting).oidFieldName
        lcUID = arcpy.Describe(landcover).oidFieldName

        #Test if the values of 'wetlandsetting' comply with the allowable notation 'Coastal plain, Karst landscape or Other'
        arcpy.AddMessage ("     - Validating wetland landscape setting values ...")
        SettingList = []
        #with arcpy.da.SearchCursor (wetlands, [wetlandsUID, wetlandSetting]) as cursor:
        with arcpy.da.SearchCursor (wetlandSetting, [settingUID, settingField]) as cursor:
            for row in cursor:
                if str(row[1]) != "Coastal plain" and str(row[1]) != "Karst landscape" and str(row[1]) != "Other":
                    SettingList.append(row[0])

        #Test if the values of 'field_HGM' comply with the allowable notation 'Floodplain, Channelled valley-bottom, Unchannelled valley-bottom, Seep, Depression or Wetland flat' OR 'VB Channelled seep Unchannelled seep River'
        idEndorheic = 0 #Must be declared before 'if' sttaement else it creates a 'local variable 'HGMList' referenced before assignment' error later on in script
        idNonEndorheic = 0 #Must be declared before 'if' sttaement else it creates a 'local variable 'HGMList' referenced before assignment' error later on in script
        HGMList = [] #Must be declared before 'if' sttaement else it creates a 'local variable 'HGMList' referenced before assignment' error later on in script
        arcpy.AddMessage ("     - Validating HGM 4A classification values ...")
        if wetlandType == "Non-depression" and field_HGM != None:
            #with arcpy.da.SearchCursor (wetlands, [wetlandsUID, field_HGM]) as cursor:
            with arcpy.da.SearchCursor (wetlands, [wetlandUID, field_HGM]) as cursor:
                for row in cursor:
                    if field_HGM != None:
                        if hgmDefault == "None":
                            if str(row[1]) != "Floodplain" and str(row[1]) != "Channelled valley-bottom" and str(row[1]) != "Unchannelled valley-bottom" and str(row[1]) != "Seep" and str(row[1]) != "Wetland flat" and str(row[1]) != "Depression" and str(row[1]) != "Valley-bottom" and str(row[1]) != "Channelled seep" and str(row[1]) != "Unchannelled seep" and str(row[1]) != "River":
                                HGMList.append(row[0])
                        else:
                            if str(row[1]) == "Depression" or str(row[1]) == "Endorheic" or str(row[1]) == "Exorheic" or str(row[1]) == "With channelled inflow" or str(row[1]) == "Without channelled inflow" or str(row[1]) == "With channelled inflow" or str(row[1]) == "Without channelled inflow":
                               idEndorheic = 1
                            if str(row[1]) == "Floodplain" or str(row[1]) == "Channelled valley-bottom" or str(row[1]) == "Unchannelled valley-bottom" or str(row[1]) == "Seep" or str(row[1]) == "Wetland flat" or str(row[1]) == "Valley-bottom" or str(row[1]) == "Channelled seep" or str(row[1]) == "Unchannelled seep" or str(row[1]) == "River":
                                idNonEndorheic = 1
                            if str(row[1]) != "Floodplain" and str(row[1]) != "Channelled valley-bottom" and str(row[1]) != "Unchannelled valley-bottom" and str(row[1]) != "Seep" and str(row[1]) != "Wetland flat" and str(row[1]) != "Depression" and str(row[1]) != "Valley-bottom" and str(row[1]) != "Channelled seep" and str(row[1]) != "Unchannelled seep" and str(row[1]) != "River" and str(row[1]) != "":
                                HGMList.append(row[0])
        else: #i.e. wetlandType == "Depression"
            if field_HGM != None:
                #with arcpy.da.SearchCursor (wetlands, [wetlandsUID, field_HGM]) as cursor:
                with arcpy.da.SearchCursor (wetlands, [wetlandUID, field_HGM]) as cursor:
                    for row in cursor:
                        if str(row[1]) == "Depression" or str(row[1]) == "Endorheic" or str(row[1]) == "Exorheic" or str(row[1]) == "With channelled inflow" or str(row[1]) == "Without channelled inflow" or str(row[1]) == "With channelled inflow" or str(row[1]) == "Without channelled inflow":
                            idEndorheic = 1
                        if str(row[1]) == "Floodplain" or str(row[1]) == "Channelled valley-bottom" or str(row[1]) == "Unchannelled valley-bottom" or str(row[1]) == "Seep" or str(row[1]) == "Wetland flat" or str(row[1]) == "Valley-bottom" or str(row[1]) == "Channelled seep" or str(row[1]) == "Unchannelled seep" or str(row[1]) == "River":
                            idNonEndorheic = 1
                        if str(row[1]) != "Depression" and str(row[1]) != "Endorheic" and str(row[1]) != "Exorheic" and str(row[1]) != "With channelled inflow" and str(row[1]) != "Without channelled inflow" and str(row[1]) != "With channelled inflow" and str(row[1]) != "Without channelled inflow":
                            HGMList.append(row[0])
            else:
                if (len(arcpy.ListFields(wetlands, "HGM_4A")) == 0):
                    arcpy.AddField_management(wetlands, "HGM_4A", "TEXT", "", "", "", "", "NULLABLE", "NON_REQUIRED", "")
                    with arcpy.da.UpdateCursor (wetlands, ["HGM_4A",]) as cursor:
                        for row in cursor:
                            row[0] = "Depression"
                            cursor.updateRow(row)
                            
        #Test if the values of 'lcField' are within the allowable broad land cover category range of 1 - 19
        arcpy.AddMessage ("     - Validating broad land cover categories ...")
        invalidLcList = []
        with arcpy.da.SearchCursor(landcover, [lcUID, lcField]) as cursor:
            for row in cursor:
                i = str(row[1])
                if i == "None":
                    invalidLcList.append(row[0])
                else:
                    if int(row[1]) < 1 or int(row[1]) > 19:
                        invalidLcList.append(row[0]) 

        arcpy.AddMessage ("     - Validating quaternary catchments ...")
        quatList = []
        with arcpy.da.SearchCursor(quatCatchment, [quatField, MAPfield, MAEfield]) as cursor:
            for row in cursor:
                i = str(row[1])
                if row[1] in ["", " ", None] or row[2] in ["", " ", None]:
                    quatList.append(row[0])

        #Report on errors found during validation
        if len(SettingList) > 0 or (idEndorheic == 1 and idNonEndorheic == 1) or len(HGMList) > 0 or len(invalidLcList) > 0 or len(quatList) > 0:
            #Report on and exit if the feature class contains invalid wetland landscape setting entries
            if len(SettingList) > 0:
                idList = ", ".join(str(x) for x in SettingList)
                arcpy.AddError ("\n   - Error: Values in field '" + settingField + "' of the hydro-geological feature class do not comply with the required values 'Coastal plain', 'Karst landscape, or 'Other' for features with 'OID's: " + str(idList) + "\n")

            #Report on and exit if the feature class contains invalid HGM entries
            if len(HGMList) > 0:
                if wetlandType == "Non-depression":
                    idList = ", ".join(str(x) for x in HGMList)
                    arcpy.AddError ("\n   - Error: Values in field '" + field_HGM + "' of the wetland feature class do not comply with the required values 'Floodplain', 'Channelled valley-bottom', 'Unchannelled valley-bottom', 'Seep', 'Wetland flat', 'Valley-bottom', 'Channelled seep', 'Unchannelled seep' or 'River' for feature with 'featOID's: " + str(idList) + ". Correct HGM value or set a default HGM type.\n")
                else:
                    idList = ", ".join(str(x) for x in HGMList)
                    arcpy.AddError ("\n   - Error: Values in field '" + field_HGM + "' of the wetland feature class do not comply with the required values 'Depression', 'Endorheic', 'Exorheic', 'With channelled inflow', or 'Without channelled inflow' for feature 'featOID's: " + str(idList) + ". Correct HGM value or set a default HGM type.\n")

            #Report on and exit if the feature class contains invalid broad land cover categories of 1 - 19
            if len(invalidLcList) > 0:
                invalidLcListid = ""
                for id in invalidLcList:
                    invalidLcListid = invalidLcListid + str(id) + ", "
                idList = invalidLcListid[:-2]#Remove the last ', '
                arcpy.AddError ("\n   - Error: Values in field '" + lcField + "' of the land cover feature class are '<NULL>' or exceed the alowable range of 1 to 19 for feature with 'featOID's: " + str(idList) + "\n")

            #Report on and exit if the feature class contains both endorheic and non-endorheic features
            if idEndorheic == 1 and idNonEndorheic == 1:
                arcpy.AddError ("\n   - Error: Features of the wetland feature class are of both depression and non-depression type. Only one type is allowed.\n")

            #Report on and exit if the not all records in the quaternary catchment fature class fields have values
            if len(quatList) > 0:
                idList = ", ".join(str(x) for x in quatList)
                arcpy.AddError ("\n   - Error: Empty values detected in either of both fields '" + MAPfield + "' and '" + MAEfield + "'. Offending quaternary catchments '" + quatField + "': " + str(idList) + "\n")
            exit()

        arcpy.AddMessage ("     - Validating spatial extent ...")
        arcpy.AddMessage ("      - Hydro-geological setting ...")
        hydroExtent = 0
        arcpy.MakeFeatureLayer_management(wetlands,"wetlands")
        arcpy.SelectLayerByLocation_management ("wetlands","INTERSECT",wetlandSetting,"", "NEW_SELECTION")
        arcpy.SelectLayerByAttribute_management("wetlands","SWITCH_SELECTION")
        #Determine if there is a selection
        desc = arcpy.Describe("wetlands")
        selection = desc.FIDSet
        if selection != "": #i.e. there is a selection
            hydroExtent = 1

        arcpy.AddMessage ("      - Quaternary catchments ...")
        quatExtent = 0
        arcpy.SelectLayerByLocation_management ("wetlands","INTERSECT",quatCatchment,"", "NEW_SELECTION")
        arcpy.SelectLayerByAttribute_management("wetlands","SWITCH_SELECTION")
        #Determine if there is a selection
        desc = arcpy.Describe("wetlands")
        selection = desc.FIDSet
        if selection != "": #i.e. there is a selection
            quatExtent = 1

        #Report on errors found during spatial validation
        if hydroExtent == 1 or quatExtent == 1:
            #Report on and exit if the feature class contains invalid wetland landscape setting entries
            if hydroExtent == 1:
                arcpy.AddError ("\n   - Error: Not all wetland intersect the hydro-geological setting feature class.\n")

            #Report on and exit if the feature class contains invalid HGM entries
            if quatExtent == 1:
                arcpy.AddError ("\n   - Error: Not all wetland intersect the quaternary catchment feature class.\n")
            exit()
        else:
            arcpy.SelectLayerByAttribute_management("wetlands","CLEAR_SELECTION")

        pesDone_one = 0
        if (len(arcpy.ListFields(wetlands, "pesDONE")) != 0): #Enter only if field 'pesDONE' exists
            pesDONEexists = 1

            if pesReset.lower() == "true":
                arcpy.AddMessage ("     - Resetting all values in field 'pesDONE' to 0 ...")
                with arcpy.da.UpdateCursor (wetlands, ["pesDONE", ]) as cursor:
                    for row in cursor:
                        if row[0] != 2:
                            row[0] = 0
                            cursor.updateRow(row)
            else:
                pesList = []
##                pesDone_one = 0
                with arcpy.da.SearchCursor (wetlands, [wetlandUID,"pesDONE",]) as cursor:
                    for row in cursor:
                        if row[1] not in [1, "", " ", None]:
                            pesList.append(row[1]) #i.e. the value in field 'pesDONE' = 0
                        else:
                            pesDone_one = 1

##                arcpy.AddMessage ("pesList: " + str(pesList))#$
                if len(pesList) > 0 and pesDone_one == 1:
                    arcpy.MakeFeatureLayer_management (wetlands,"wetlands")
                    sql = "pesDONE = 0"
                    arcpy.SelectLayerByAttribute_management("wetlands", "NEW_SELECTION", sql)# Select the wetland
                    pesDONEsel = scratchWorkspace + "\\pesDONEsel"
                    arcpy.CopyFeatures_management("wetlands",pesDONEsel)
                    wetlands = pesDONEsel #set 'wetlands' to the new feature class that contains only records of those with value 0 in field 'pesDONE'
##                    arcpy.CopyFeatures_management(wetlands,r'C:\NWM\scratch.gdb\wetlands')#$
                else:
                    arcpy.AddWarning ("\n   - WARNING: No records qualify for analysis.")
                    arcpy.AddError ("       - Consider checking parameter 'Reset all values of field 'pesDONE' to 0'.\n")
                    exit()
        else:
            arcpy.AddField_management (wetlands, "pesDONE", "SHORT", "", "", "", "", "NULLABLE", "NON_REQUIRED", "")
            with arcpy.da.UpdateCursor (wetlands, ["pesDONE", ]) as cursor:
                for row in cursor:
                    row[0] = 0
                    cursor.updateRow(row)
##        exit()#$
                            
        #Add field to hold default HGM if no HGM field was indicated and hgmDefault <> 'None'
        if field_HGM == None and hgmDefault != "None":
            if "HGM_default" not in [field.name for field in arcpy.ListFields(wetlands)]:
                arcpy.AddField_management (wetlands, "HGM_default", "TEXT", "", "", 5)
                field_HGM = "HGM_default"

        arcpy.AddMessage ("     - Creating required output fields ...")
##        PES_fields = ["IMPACT_HYD", "PES_HYDRO", "EC_HYDRO", "IMPACT_GEO", "PES_GEO", "EC_GEO", "IMPACT_WQ", "PES_WQ", "EC_WQ", "IMPACT_VEG", "PES_VEG", "EC_VEG", "IMPACT_ALL", "PES_ALL", "EC_ALL", "SEC_ALL", "HA_EQUIV", "Confidence", "wshedInBuffer", "wetlandLandcover", "bufferLandcover", "wshedLandcover", "wshedInWetland", "pesDONE", "lcWetl_perc", "lcBuffer_perc", "lcWshed_perc", "validPES"]

        PES_fields = ["IMPACT_HYD", "PES_HYDRO", "EC_HYDRO", "IMPACT_GEO", "PES_GEO", "EC_GEO", "IMPACT_WQ", "PES_WQ", "EC_WQ", "IMPACT_VEG", "PES_VEG", "EC_VEG", "IMPACT_ALL", "PES_ALL", "EC_ALL", "SEC_ALL", "HA_EQUIV", "Confidence", "wshedInBuffer", "wetlandLandcover", "bufferLandcover", "wshedLandcover", "wshedInWetland", "lcWetl_perc", "lcBuffer_perc", "lcWshed_perc", "validPES"]
        for wet in [wetlands,wetlands_org]:
            for field in PES_fields:
##                arcpy.AddMessage ("      - Field '" + field + "' ...")
                if (len(arcpy.ListFields(wet, field)) == 0): #Only add the field if it does not already exist
                    if field == "Confidence" or field == "EC_HYDRO" or field == "EC_GEO" or field == "EC_WQ" or field == "EC_VEG" or field == "EC_ALL" or field == "SEC_ALL":
                        if field == "Confidence":
                            arcpy.AddField_management (wet, field, "TEXT", "", "", "")
                        else:
                            if field == "SEC_ALL":
                                arcpy.AddField_management (wet, field, "TEXT", "", "", 3)
                            else:
                                arcpy.AddField_management (wet, field, "TEXT", "", "", 2)
                    else:
                        if field == "wshedInBuffer" or field == "wetlandLandcover" or field == "bufferLandcover" or field == "wshedLandcover" or field == "wshedInWetland"  or field == "pesDONE" or field == "validPES":
                            arcpy.AddField_management (wet, field, "SHORT", "", "", "", "", "NULLABLE", "NON_REQUIRED", "")
                        else:
                            arcpy.AddField_management (wet, field, "DOUBLE", "", "", "", "", "NULLABLE", "NON_REQUIRED", "")
##        arcpy.CopyFeatures_management(wetlands,r'C:\NWM\scratch.gdb\data\wetlands')#$
##        arcpy.CopyFeatures_management(wetlands_org,r'C:\NWM\scratch.gdb\data\wetlands_org')#$

        #Restore the values of field 'pesDONE' from dictionary 'pesDONEdic'
        wetlandIDList = []
            #                       0           1           2           3           4           5           6           7           8       9          10          11          12          13          14       15          16          17          18              19              20                  21                  22              23              24          25              26              27              28
        PES_fields_clear = [wetlandUID, "IMPACT_HYD", "PES_HYDRO", "EC_HYDRO", "IMPACT_GEO", "PES_GEO", "EC_GEO", "IMPACT_WQ", "PES_WQ", "EC_WQ", "IMPACT_VEG", "PES_VEG", "EC_VEG", "IMPACT_ALL", "PES_ALL", "EC_ALL", "SEC_ALL", "HA_EQUIV", "Confidence", "wshedInBuffer", "wetlandLandcover", "bufferLandcover", "wshedLandcover", "wshedInWetland", "pesDONE", "lcWetl_perc", "lcBuffer_perc", "lcWshed_perc", "validPES"]
        with arcpy.da.UpdateCursor (wetlands, PES_fields_clear) as cursor:
            for row in cursor:                                
                wetlandIDList.append(row[0])
                row[1] = 0.0 # IMPACT_HYD
                row[2] = 0.0 # PES_HYDRO
                row[3] = None # EC_HYDRO
                row[4] = 0.0 # IMPACT_GEO
                row[5] = 0.0 # PES_GEO
                row[6] = None # EC_GEO
                row[7] = 0.0 # IMPACT_WQ
                row[8] = 0.0 # PES_WQ
                row[9] = None # EC_WQ
                row[10] = 0.0 # IMPACT_VEG
                row[11] = 0.0 # PES_VEG
                row[12] = None # EC_VEG
                row[13] = 0.0 # IMPACT_ALL
                row[14] = 0.0 # PES_ALL
                row[15] = None # EC_ALL
                row[16] = None # SEC_ALL
                row[17] = 0.0 # HA_EQUIV
                row[18] = None # Confidence
                row[19] = 0 # wshedInBuffer
                row[20] = 0 # wetlandLandcover
                row[21] = 0 # bufferLandcover
                row[22] = 0 # wshedLandcover
                row[23] = 0 # wshedInWetland
##                row[24] = 0 # pesDONE
                row[25] = 0.0 # lcWetl_perc
                row[26] = 0.0 # lcBuffer_perc
                row[27] = 0.0 # lcWshed_perc
                row[28] = 0 # validPES
                cursor.updateRow(row)

        #Confirm that all wetlands with value 0 in field 'pesDONE' and correct HGM value have a watershed - remove UID value from 'wetlandIDList' if no watershed for that feature
        arcpy.AddMessage ("     - Validating features and watersheds ...")
        watershedIDList = []
        with arcpy.da.SearchCursor (watersheds, [field_watersheds, ]) as cursor:
            for row in cursor:
                watershedIDList.append(row[0])

        noWatershedList = []
        for i in wetlandIDList:
            if i not in watershedIDList:
                noWatershedList.append(i)
        
        if len(noWatershedList) > 0:
            noWatershedValue = ", ".join(str(x) for x in noWatershedList)
            arcpy.AddWarning ("      - WARNING: No watershed for wetlands with '" + str(wetlandUID) + "' values: " + str(noWatershedValue))
        else:
            arcpy.AddWarning ("      - All wetlands have watersheds.")

        #Add and populate field 'wetlID' to enact an 'Erase' procedure $#Confirm if necessary to enact erase later on and if bufferID = 1 is not sufficient
        if "wetlID_" not in [f.name for f in arcpy.ListFields(wetlands)]:
            arcpy.AddField_management (wetlands, "wetlID_", "LONG", "", "", "", "", "NULLABLE", "NON_REQUIRED", "")

        with arcpy.da.UpdateCursor (wetlands, ["wetlID_", ]) as cursor:
            for row in cursor:
                row[0] = 1
                cursor.updateRow(row)

        #Create a list with the wetland OBJECTID values and a dictionary with the HGM type
        arcpy.AddMessage ("     - Creating dictionary of feature per HGM type ...")
        HGM_typeDic = {}
##        wetSetDic = {}
        if wetlandType == "Non-depression":
            #with arcpy.da.UpdateCursor (wetlands, [wetlandsUID, field_HGM, wetlandSetting]) as cursor: #If wetlandType = 'Non-endorheic', then set wetland type according to value of field 'field_HGM'
##            with arcpy.da.UpdateCursor (wetlands, [wetlandUID, field_HGM, settingField]) as cursor: #If wetlandType = 'Non-endorheic', then set wetland type according to value of field 'field_HGM'
            with arcpy.da.UpdateCursor (wetlands, [wetlandUID, field_HGM]) as cursor: #If wetlandType = 'Non-endorheic', then set wetland type according to value of field 'field_HGM'
                for row in cursor:
##                    wetSetDic[row[0]] = row[2]
                    if field_HGM == "HGM_default" or (field_HGM != None and hgmDefault != "None"): 
                        if field_HGM == "HGM_default": #A field with HGM type was NOT specified as well as a default HGM type to allow for assessment
                            #Add the value of the default HGM type with suffix '*' to field with the HGM types for features with no value in field with HGM types and Default HGM <> 'None'
                            if hgmDefault == "Floodplain":
                                row[1] = "Floodplain*"
                                HGM_typeDic[row[0]] = "Floodplain"
                            if hgmDefault == "Channelled valley-bottom":
                                row[1] = "Channelled valley-bottom*"
                                HGM_typeDic[row[0]] = "Channelled valley-bottom"
                            if hgmDefault == "Unchannelled valley-bottom":
                                row[1] = "Unchannelled valley-bottom*"
                                HGM_typeDic[row[0]] = "Unchannelled valley-bottom"
                            if hgmDefault == "Seep":
                                row[1] = "Seep*"
                                HGM_typeDic[row[0]] = "Seep"
                            if hgmDefault == "Depression":
                                row[1] = "Depression*"
                                HGM_typeDic[row[0]] = "Depression"
                            if hgmDefault == "Flat":
                                row[1] = "Wetland flat*"
                                HGM_typeDic[row[0]] = "Wetland flat"

                        if field_HGM != "HGM_default" and field_HGM != None and hgmDefault != "None": #A field with HGM type was specified as well as a default HGM type to account for records with no HGM in field 'field_HGM'
                            #Add the value of the default HGM type with suffix '*' to field with the HGM types for features with no value in field with HGM types and Default HGM <> 'None'
                            if row[1] == "":
                                if hgmDefault == "Floodplain":
                                    row[1] = "Floodplain*"
                                    HGM_typeDic[row[0]] = "Floodplain"
                                if hgmDefault == "Channelled valley-bottom":
                                    row[1] = "Channelled valley-bottom*"
                                    HGM_typeDic[row[0]] = "Channelled valley-bottom"
                                if hgmDefault == "Unchannelled valley-bottom":
                                    row[1] = "Unchannelled valley-bottom*"
                                    HGM_typeDic[row[0]] = "Unchannelled valley-bottom"
                                if hgmDefault == "Seep":
                                    row[1] = "Seep*"
                                    HGM_typeDic[row[0]] = "Seep"
                                if hgmDefault == "Depression":
                                    row[1] = "Depression*"
                                    HGM_typeDic[row[0]] = "Depression"
                                if hgmDefault == "Flat":
                                    row[1] = "Wetland flat*"
                                    HGM_typeDic[row[0]] = "Wetland flat"
                            else:
                                if row[1] == "River" or row[1] == "Valley-bottom" or row[1] == "Channelled seep" or row[1] == "Unchannelled seep": #Account for values Valley-bottom, Channelled seep, Unchannelled seep, River in 'field_HGM' 
                                    if row[1] == "River":
                                        HGM_typeDic[row[0]] = "Channelled valley-bottom"
                                    if row[1] == "Valley-bottom":
                                        HGM_typeDic[row[0]] = "Unchannelled valley-bottom"
                                    if row[1] == "Channelled seep" or row[1] == "Unchannelled seep":
                                        HGM_typeDic[row[0]] = "Seep"
                                else:
                                    HGM_typeDic[row[0]] = row[1]
                    else: #A field with HGM type was specified while no default HGM type specified
                        if row[1] == "River" or row[1] == "Valley-bottom" or row[1] == "Channelled seep" or row[1] == "Unchannelled seep": #Account for values Valley-bottom, Channelled seep, Unchannelled seep, River in 'field_HGM' 
                            if row[1] == "River":
                                HGM_typeDic[row[0]] = "Channelled valley-bottom"
                            if row[1] == "Valley-bottom":
                                HGM_typeDic[row[0]] = "Unchannelled valley-bottom"
                            if row[1] == "Channelled seep" or row[1] == "Unchannelled seep":
                                HGM_typeDic[row[0]] = "Seep"
                        else:
                            HGM_typeDic[row[0]] = row[1]
                    cursor.updateRow(row)
        else:
            if field_HGM not in ["", " ", None]:
                #with arcpy.da.UpdateCursor (wetlands, [wetlandsUID, field_HGM, wetlandSetting]) as cursor: #If wetlandType = 'Non-endorheic', then set wetland type according to value of field 'field_HGM'
                with arcpy.da.SearchCursor (wetlands, [wetlandUID, field_HGM, settingField]) as cursor: #If wetlandType = 'Non-endorheic', then set wetland type according to value of field 'field_HGM'
                    for row in cursor:
                        wetSetDic[row[0]] = row[2]
                        if row[1] =="Depression" or row[1] == "With channelled inflow" or row[1] == "Without channelled inflow" or row[1] == "With channelled inflow" or row[1] == "Without channelled inflow":
                            HGM_typeDic[row[0]] = "Depression"
            else:
                #with arcpy.da.SearchCursor (wetlands, [wetlandsUID, wetlandSetting]) as cursor: #If wetlandType = 'Endorheic', then set all wetland type to "Depression"
                with arcpy.da.SearchCursor (wetlands, [wetlandUID, settingField]) as cursor: #If wetlandType = 'Endorheic', then set all wetland type to "Depression"
                    for row in cursor:
                        wetSetDic[row[0]] = row[2]
                        HGM_typeDic[row[0]] = "Depression"

        ##GET THE LAND COVER STATISTICS
        #Create a list of the land cover gridcodes (land cover classes)
        arcpy.AddMessage ("     - Creating multiplier dictionaries ...") 

        ##ORIGINAL SCORES - CREATE THE LEVEL 1A MULTIPLIER LOOKUP TABLES (DICTIONARIES) FOR THE DIFFERENT LAND COVER CLASSES
        ## WETLAND IMPACT INTENSITY SCORES
        Int_Wet_Hydro = {1:0, 2:7, 3:0, 4:4, 5:7, 6:8, 7:7.5, 8:7, 9:7, 10:7, 11:9, 12:10, 13:10, 14:7, 15:10, 16:7, 17:10, 18:6, 19:3}
        Int_Wet_Geo_Pr = {1:0, 2:4, 3:0, 4:2, 5:5, 6:6, 7:6, 8:6, 9:4, 10:1, 11:9, 12:10, 13:10, 14:7, 15:10, 16:4, 17:8, 18:6, 19:4}
        Int_Wet_Geo_St = {1:0, 2:4, 3:0, 4:1, 5:2, 6:2, 7:2, 8:2, 9:2, 10:1, 11:10, 12:10, 13:10, 14:8, 15:10, 16:8, 17:8, 18:5, 19:1}
        Int_Wet_WQ = {1:0, 2:0, 3:0.4, 4:0.8, 5:6.1, 6:6.4, 7:6.9, 8:6.5, 9:3.6, 10:1.2, 11:2.1, 12:8.4, 13:10, 14:2.2, 15:8.2, 16:7.6, 17:5, 18:4, 19:4.2}
        Int_Wet_Veg = {1:0, 2:10, 3:1, 4:6, 5:10, 6:10, 7:10, 8:10, 9:10, 10:10, 11:9, 12:10, 13:10, 14:9, 15:10, 16:9, 17:10, 18:6, 19:9}

        ## AREA OF INFLUENCE IMPACT INTENSITY SCORES
        Int_Ext_MAR = {1:0, 2:-8, 3:0, 4:0, 5:-5, 6:-4, 7:-5, 8:-2, 9:-2, 10:-6.5, 11:-1, 12:-4, 13:-5, 14:2, 15:2, 16:2, 17:2, 18:2, 19:-1}
        Int_Ext_Seas = {1:0, 2:3, 3:0, 4:0, 5:4, 6:1, 7:4, 8:1, 9:1, 10:0, 11:1, 12:2, 13:2, 14:0, 15:1, 16:1, 17:2, 18:1, 19:1}
        Int_Ext_Peak = {1:0, 2:-9, 3:0, 4:1.5, 5:2, 6:2, 7:3, 8:3, 9:3, 10:0, 11:4, 12:5, 13:5, 14:5, 15:9, 16:7, 17:7, 18:5, 19:3}
        Int_Ext_Sed = {1:0, 2:-8, 3:0.5, 4:2, 5:4, 6:6, 7:8, 8:7, 9:6, 10:4, 11:9, 12:9, 13:9, 14:9, 15:4, 16:5, 17:3, 18:2, 19:2}
        Int_Ext_WQ = {1:0, 2:0, 3:0.3, 4:0.6, 5:4.1, 6:4.3, 7:4.6, 8:4.3, 9:2.4, 10:0.6, 11:1.4, 12:5.6, 13:6.7, 14:1.5, 15:5.5, 16:5.1, 17:3.3, 18:2.7, 19:2.8}

        PES_summary_dic = {} # Dictionary to hold the results of the PES analysis for each wetland

        #HGM ADJUSTMENT FACTORS
        HGMdic = {"Floodplain":[0.8,0.2], "Channelled valley-bottom":[0.5,0.5], "Unchannelled valley-bottom":[0.5,0.5], "Seep":[0.2,0.8], "Depression":[0.2,0.8], "Wetland flat":[0.2,0.8], "Channelled seep":[0.2,0.8], "Unchannelled seep":[0.2,0.8]}

        #FLOODPEAK ADJUSTMENT FACTORS
        weightPeak_dic = {"Floodplain":[0.3,0.9], "Channelled valley-bottom":[0.4,0.6], "Unchannelled valley-bottom":[0.5,0.4], "Seep":[0.7,0.2], "Depression":[0.5,0.3], "Wetland flat":[0.5,0.3], "Channelled seep":[0.7,0.2], "Unchannelled seep":[0.7,0.2]}

        #Create variables for wetland, buffer and watershed analysis
        mergedWetlBuff = scratchWorkspace + "\\mergedWetlBuff"
        erasedWshed = scratchWorkspace + "\\erasedWshed"
        wshedInsideUnion = scratchWorkspace + "\\wshedInsideUnion"
        wshedInsideUnionCopy = scratchWorkspace + "\\wshedInsideUnionCopy"
        wshedInsideUnionTmp = scratchWorkspace + "\\wshedInsideUnionTmp" #temp
        wetlandBuffer = scratchWorkspace + "\\wetlandBuffer"
        wetlandUpstreamBuffer = scratchWorkspace + "\\wetlandUpstreamBuffer"
        upstreamThreshold = scratchWorkspace + "\\upstreamThreshold"
        bufferErasedtmp = scratchWorkspace + "\\bufferErasedtmp"
        bufferErased = scratchWorkspace + "\\bufferErased"
        lc_wetland = scratchWorkspace + "\\lc_wetland"
        lc_buffer = scratchWorkspace + "\\lc_buffer"
        lc_watershed = scratchWorkspace + "\\lc_watershed"
        wetlandWatershed = scratchWorkspace + "\\wetlandWatershed"
        wetlandBufferMerge = scratchWorkspace + "\\wetlandBufferMerge"
        bufferThreshold = scratchWorkspace + "\\bufferThreshold"
        watershedThreshold = scratchWorkspace + "\\watershedThreshold"
        polToRaster = scratchWorkspace + "\\polToRaster"

        #New variable for batc processing
        fcUnion = scratchWorkspace + "\\fcUnion"
        tempFC = scratchWorkspace + "\\tempFC"
        fcUnion_buffers = scratchWorkspace + "\\fcUnion_buffers"

        #Copy the watersheds to the 'in_memory' workspace
        #First select only the watersheds of wetlands of which their PES has not been determined yet and that have accomponying wetlands
        if (len(arcpy.ListFields(watersheds, "pesDONE")) == 0):
            arcpy.AddField_management (watersheds, "pesDONE", "SHORT", "", "", "", "", "NULLABLE", "NON_REQUIRED", "")
        with arcpy.da.UpdateCursor (watersheds, [field_watersheds, "pesDONE"]) as cursor:
            for row in cursor:
                if row[0] in wetlandIDList: #The watersheds wetland is earmarked for analsyis
                    row[1] = 0 
                else:
                    row[1] = 1 #The watersheds wetland is NOT earmarked for analsyis
                cursor.updateRow(row)
                
        sql = "pesDONE = " + str(0)
        arcpy.MakeFeatureLayer_management (watersheds, "watersheds")
        arcpy.SelectLayerByAttribute_management("watersheds", "NEW_SELECTION", sql)

##        try:
##            if dataToMemory.lower() == 'true':
##                #Copy the landcover to the 'in_memory' workspace
##                landcover_inmemory = scratchWorkspace + "\\landcover_inmemory"
##                arcpy.CopyRaster_management (landcover, landcover_inmemory)
##                landcover = scratchWorkspace + "\\landcover"
##                arcpy.CopyRaster_management (landcover_inmemory, landcover)
##                arcpy.Delete_management (landcover_inmemory)
##
##                #Copy the quarternary catchment to the 'in_memory' workspace
##                quat_inmemory = scratchWorkspace + "\\quat_inmemory"
##                arcpy.CopyFeatures_management (quatCatchment, quat_inmemory)
##                quatCatchment = scratchWorkspace + "\\quatCatchment"
##                arcpy.CopyFeatures_management (quat_inmemory, quatCatchment)
##                arcpy.Delete_management (quat_inmemory)
##        except:
##            arcpy.AddError("An unexpected error occured. Suspect out of memory. Uncheck parameter 'Copy the land cover grid and quaternary catchments to memory'")
##            exit()

        ##ANALYZING ...
        arcpy.AddMessage ("\n>>> Analyzing ...")
        
        ##The following block writes the wetland, buffer and watershed land cover areas (ha) to the parameter text file
##        lcList = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19] 
        txtWetlandAreaListFin = {}
        txtBufferAreaListFin = {}
        txtWatershedAreaListFin_incl = {}
        txtWatershedAreaListFin_excl = {}
        quatDic = {} #To get the MAPfield, MAEfield, MARfield values of each wetland to write to parameter text file
        vulnFactDic = {} #To hold the vulnerability score of each wetland

        lcClasses = []
        insideWetlList = []
        wshedInsideBufferList = [] #List to hold the OBJECTID number of wetland features of which their watersheds are entirely within the 200m buffer
        lcWetlandList = [] #List to hold the OBJECTID number of wetland features of which the land cover differs by more than 0.01 ha
        lcBufferList = [] #List to hold the OBJECTID number of buffer features of which the land cover differs by more than 0.01 ha
        lcWatershedList = [] #List to hold the OBJECTID number of watershed features of which the land cover differs by more than 0.01 ha
        lcBufferWatershedList = [] #List to hold the OBJECTID number of wetlands of which the watershed does not extend beyond the wetland
        lcWetlandListDic = {} #Dictionary to hold the OBJECTID number and percentage difference between wetland and wetland land cover
        lcBufferListDic = {} #Dictionary to hold the OBJECTID number and percentage difference between buffer and wetland land cover
        lcWatershedListDic = {} #Dictionary to hold the OBJECTID number and percentage difference between watershed and wetland land cover

        resultsPrintDic = {} #Dictionary to hold the PES results from where they are written to the parameter text file
        lc_gridcodes = []
        watershedInBuffer = 0
        PES_output = []
        allIDsList = []
##        adjustedNatList = []

        #calculatePES(parameterCounter, featureCounter, nFeatures) #Calculate the wetland PES
        arcpy.MakeFeatureLayer_management(wetlands,"wetlands")
        calculatePES(upstreamDistance,wetlands,lcField,wetlands_org) #Calculate the wetland PES

        # #"lcWetl", "lcBuffer", "lcWshed", "lcAll"
        #update field 'wshedLandcover' (watershed land cover total differs > 10% of watershed area)
        #                                       0           1               2                   3               4                   5           6           7       8       
        #with arcpy.da.UpdateCursor (wetlands, ["OID@","wshedInBuffer","wshedInWetland","wetlandLandcover","bufferLandcover","wshedLandcover","lcWetl_perc","lcBuffer_perc","lcWshed_perc"]) as cursor:
        with arcpy.da.UpdateCursor (wetlands, [wetlandUID,"wshedInBuffer","wshedInWetland","wetlandLandcover","bufferLandcover","wshedLandcover","lcWetl_perc","lcBuffer_perc","lcWshed_perc"]) as cursor:
            for row in cursor:
                if row[0] in wshedInsideBufferList:
                    row[1] = 1
                else:
                    row[1] = 0

                if row[0] in insideWetlList:
                    row[2] = 1
                else:
                    row[2] = 0

                if row[0] in lcWetlandList:
                    row[3] = 1
                else:
                    row[3] = 0
                cursor.updateRow(row)

                if row[0] in lcBufferList:
                    row[4] = 1
                else:
                    row[4] = 0

                if row[0] in lcWatershedList:
                    row[5] = 1
                else:
                    row[5] = 0

                if row[0] in lcWetlandListDic:
                    row[6] = round(lcWetlandListDic[row[0]],2)
                if row[0] in lcBufferListDic:
                    row[7] = round(lcBufferListDic[row[0]],2)
                if row[0] in lcWatershedListDic:
                    row[8] = round(lcWatershedListDic[row[0]],2)
                cursor.updateRow(row)                

        #                                           0               1                2          3
        with arcpy.da.UpdateCursor (wetlands, ["lcWetl_perc","lcBuffer_perc","lcWshed_perc","validPES"]) as cursor:
            for row in cursor:
                if row[0] <int(errThreshold) and row[1] <int(errThreshold) and row[2] <int(errThreshold):
                    row[3] = 1
                else:
                    row[3] = 0
                cursor.updateRow(row)  

        ##CREATE THE PARAMETERS TEXT FILE
        if len(wshedInsideBufferList) > 0 or len(insideWetlList) > 0 or len(lcWetlandList) > 0 or len(lcBufferList) > 0 or len(lcWatershedList) > 0:
            arcpy.AddWarning ("\nRESULTS:")
        wetlandIDList.sort()
        paraPath = parameterFolder + "\\Level 1A PES_" + now.strftime("%Y_%m_%d_%H_%M") + ".txt"

        parafile = open(paraPath, "w")
        parafile.writelines("LEVEL 1A PES RESULTS\n")
        parafile.writelines("____________________________\n\n")

        #Write the parameters
        for para in parameters:
            parafile.writelines("\n" + para)

        #Write wetland unique identifier of those that do not have watersheds
        if len(noWatershedList) > 0:
            parafile.writelines("\n")
            #parafile.writelines("\nWARNING: No watershed for wetland features with " + str(wetlandsUID))
            parafile.writelines("\nWARNING: No watershed for wetland features with " + str(wetlandUID))
            parafile.writelines("\n" + str(noWatershedValue))   

        if len(resultsPrintDic) > 0: #Only enter if results were generated
            if len(insideWetlList) > 0:
                for item in insideWetlList:
                    if item in wshedInsideBufferList:
                        wshedInsideBufferList.remove(item)
                        
            #Write the watershed is completely containd within the buffer warning
            results = ""
            if len(wshedInsideBufferList) > 0:
                for lcError in wshedInsideBufferList:
                    results += str(lcError) + ", "
                results = results[:-2]
                arcpy.AddWarning (">> WARNING: The watershed is completely contained within the 200 meter buffer for wetland features with " + str(wetlandUID) + ": " + str(results) + ". The wetland PES was determined on account of the watershed area only.")
                parafile.writelines("\n")
                parafile.writelines("\nWARNING: The watershed is completely contained within the 200 meter buffer for wetland features " + str(wetlandUID) + ". (The wetland PES was determined on account of the watershed area only): ")
                parafile.writelines("\n" + str(results))

            #Write the watershed does not extend beyond the wetland
            if len(insideWetlList) > 0:
                #Write the watershed is completely containd within the wetland warning
                results = ""
                for lcError in insideWetlList:
                    results += str(lcError) + ", "
                results = results[:-2]
                arcpy.AddWarning (">> WARNING: Watershed does not extend beyond the wetland for wetland features with " + str(wetlandUID) + ": " + str(results) + ". The wetland PES was determined on account of the wetland area only.")
                parafile.writelines("\n")
                parafile.writelines("\nWARNING: Watershed does not extend beyond the wetland for wetland features with " + str(wetlandUID) + ". (The wetland PES was determined on account of the wetland area only): ")
                parafile.writelines("\n" + str(results))

            #Write the wetland land cover area errors 
            results = ""
            if len(lcWetlandList) > 0:
                lcWetlandList.sort()
                for lcError in lcWetlandList:
                    results += str(lcError) + ", "
                results = results[:-2]
                arcpy.AddWarning (">> WARNING: Total wetland land cover area differs by >" + str(errThreshold) + "% from wetland area for wetland features " + str(wetlandUID) + ": " + str(results))
                parafile.writelines("\n")
                parafile.writelines("\nWARNING: >" + str(errThreshold) + "% difference between total wetland area and total wetland land cover area for wetland features with " + str(wetlandUID) + ":")
                parafile.writelines("\n" + str(results))

            #Write the bufer land cover area errors
            results = ""
            if len(lcBufferList) > 0:
                lcBufferList.sort()
                for lcError in lcBufferList:
                    results += str(lcError) + ", "
                results = results[:-2]
                arcpy.AddWarning (">> WARNING: Total buffer land cover area differs by >" + str(errThreshold) + "% from buffer area for wetland features with " + str(wetlandUID) + ": " + str(results))
                parafile.writelines("\n")
                parafile.writelines("\nWARNING: >" + str(errThreshold) + "% difference between total buffer area and total buffer land cover area for wetland features with " + str(wetlandUID) + ":")
                parafile.writelines("\n" + str(results))

            #Write the watershed land cover area errors
            results = ""
            if len(lcWatershedList) > 0:
                lcWatershedList.sort()
                for lcError in lcWatershedList:
                    results += str(lcError) + ", "
                results = results[:-2]
                arcpy.AddWarning (">> WARNING: Total watershed land cover area differs by >" + str(errThreshold) + "% from watershed area for wetland features with " + str(wetlandUID) + ": " + str(results))
                parafile.writelines("\n")
                parafile.writelines("\nWARNING: >" + str(errThreshold) + "% difference between total watershed area and total watershed land cover area for wetland features with " + str(wetlandUID) + ":")
                parafile.writelines("\n" + str(results))

            #Write the wetland land cover area differences
            if len(lcWetlandListDic) > 0:
                parafile.writelines ("\n\nWetland ID and percent difference between total wetland area and total wetland land cover area")
                try:
                    for n in allIDsList:
                        parafile.writelines("\nOID " + str(n) + ":\t" + str(lcWetlandListDic[n]) + "%")
                except:
                    pass

            #Write the wetland land cover area differences
            if len(lcBufferListDic) > 0:
                parafile.writelines ("\n\nWetland ID and percent difference between total buffer area and total buffer land cover area")
                try:
                    for n in allIDsList:
                        parafile.writelines("\nOID " + str(n) + ":\t" + str(lcBufferListDic[n]) + "%")
                except:
                    pass

            #Write the wetland land cover area differences
            if len(lcWatershedListDic) > 0:
                parafile.writelines ("\n\nWetland ID and percent difference between total watershed area and total watershed land cover area (excluding wetland and buffer)")
                try:
                    for n in allIDsList:
                        parafile.writelines("\nOID " + str(n) + ":\t" + str(lcWatershedListDic[n]) + "%")
                except:
                    pass
                
            #Write the PES assessment results
            PES_fields.insert(0, "WetlID") #Add heading 'WetlID' so that it is included as a heading in the text file
            pesFields = ", ".join(PES_fields)
            parafile.writelines("\n")
            parafile.writelines("\n" + pesFields)
            #Print the wetland land cover area to the text file allIDs
            #for id in wetlandIDList:
            for id in allIDsList:
                if id in resultsPrintDic:
                    values = resultsPrintDic[id]
                    values.insert(0,str(id))
                    pesValues = ", ".join(values)
                    parafile.writelines("\n" + pesValues)
                 
            ##The following block is temporary and writes the wetland, buffer and watershed land cover areas (ha) to the paremeter text file
            #BLOCK START
            lcFields = ["featOID", "WATER_NAT", "DAM", "NATURAL", "SEMI_NAT", "ORCH_VINE", "SUGARCANE", "CROP_IRRIG", "CROP_NOIRR", "CROP_SUBS", "PLANT_INV", "MINING_L", "MINING_M", "MINING_H", "ERODED", "INDUS_COMM", "INFORMAL", "RESIDENT_H", "RESIDENT_L", "OPENSPACE"]
            strHeadings = str(lcFields)
            strHeadings = strHeadings[:-1] #Remove the "]"
            strHeadings = strHeadings[1:] #Remove the "["
            strHeadingstxt = strHeadings.replace("'", "")

            #Write the wetland land cover areas 
            parafile.writelines("\n")
            parafile.writelines("\nWetland land cover area (ha)")
            parafile.writelines("\n" + strHeadingstxt)
            #Print the wetland land cover area to the text file

            for id in allIDsList:
                values = txtWetlandAreaListFin[id]
                values.insert(0,str(id))
                haValues = ", ".join(values)
                parafile.writelines("\n" + haValues)

            #Write the buffer land cover areas
            parafile.writelines("\n")
            parafile.writelines("\nBuffer land cover area (ha) (excluding wetland area)")
            parafile.writelines("\n" + strHeadingstxt)

            for id in allIDsList:
                values = txtBufferAreaListFin[id]
                values.insert(0,str(id))
                haValues = ", ".join(values)
                parafile.writelines("\n" + haValues)

            #Write the watershed land cover areas
            parafile.writelines("\n")
            parafile.writelines("\nWatershed land cover area (ha) (including wetland and buffer)")
            parafile.writelines("\n" + strHeadingstxt)

            for id in allIDsList:
                values = txtWatershedAreaListFin_incl[id]
                values.insert(0,str(id))
                haValues = ", ".join(values)
                parafile.writelines("\n" + haValues)

            #Write the watershed land cover areas
            parafile.writelines("\n")
            parafile.writelines("\nWatershed land cover area (ha) (excluding wetland and buffer)")
            parafile.writelines("\n" + strHeadingstxt)

            for id in allIDsList:
                values = txtWatershedAreaListFin_excl[id]
                values.insert(0,str(id))
                haValues = ", ".join(values)
                parafile.writelines("\n" + haValues) 

            #Write the Quaternary catchment values
            parafile.writelines("\n")
            parafile.writelines("\nQuaternary catchment hydrology data")
            parafile.writelines("\nWetlID, MAPfield, MAEfield")
            strListtxt = ""

            for n in allIDsList:
                try:                
                    quatValues = quatDic.get(n)
                    strListtxt = str(n) + ", " 
                    for values in quatValues:
                        strListtxt += str(values) + ", "
                    strListtxt = strListtxt[:-2] #Remove the last ","
                    parafile.writelines("\n" + strListtxt)
                except Exception:
                    strListtxt = str(n) + ", 0, 0"
                    parafile.writelines("\n" + strListtxt)
                    continue

            #Write the HGM type
            hgmDic = {"Floodplain":"FP","Channelled valley-bottom":"CVB","Unchannelled valley-bottom":"UVB","Seep":"SEEP","Wetland flat":"FLAT","Depression":"DEP","Valley-bottom":"CVB","Channelled seep":"SEEP","Unchannelled seep":"SEEP","River":"RIVER"}
            parafile.writelines("\n")
            parafile.writelines("\nHGM type")
            parafile.writelines("\nWetlID, HGM")
            strListtxt = ""

            for n in allIDsList:
                try:                
                    hgmValues = HGM_typeDic[n]
                    hgmValues = hgmDic[hgmValues]
                    strListtxt = str(n) + ", " + hgmValues
                    parafile.writelines("\n" + strListtxt)
                except:
                    pass

            parafile.close()
            #BLOCK END

            arcpy.AddMessage ("\n>>> Parameter text file created at location: '" + str(paraPath) + "'\n")

        else:
            arcpy.AddWarning ("\n>>> No results were created.\n")
            parafile.writelines("\n\n>>> No results were created.")
            parafile.close()

        #Delete temporary fields
        try:
            arcpy.DeleteField_management ("wetlands", ["WetlID_", ]) #$ Confirm that there are no other temporary fields that need to be deleted here in in following watershed tools
        except:
            pass

        ##DELETE THE INTERMEDIATE DATA
        if blnInMemory.lower() == 'false':
            arcpy.AddMessage ("\n>>> Deleting the intermediate data ...\n")
        else:
            arcpy.AddMessage ("\n>>> Clearing the 'in_memory' workspace and intermediate data...\n")
            arcpy.Delete_management ("in_memory")
        clearScratch() 

```
